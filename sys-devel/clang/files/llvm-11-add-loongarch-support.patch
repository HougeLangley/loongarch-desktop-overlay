diff --git a/clang/include/clang/Basic/BuiltinsLoongArch.def b/clang/include/clang/Basic/BuiltinsLoongArch.def
new file mode 100644
index 000000000000..7e281463b118
--- /dev/null
+++ b/clang/include/clang/Basic/BuiltinsLoongArch.def
@@ -0,0 +1,56 @@
+//===-- BuiltinsLoongArch.def - LoongArch Builtin function database --------*- C++ -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the LoongArch-specific builtin function database. Users of
+// this file must define the BUILTIN macro to make use of this information.
+//
+//===----------------------------------------------------------------------===//
+
+// The format of this database matches clang/Basic/Builtins.def.
+
+// LoongArch BASE
+
+BUILTIN(__builtin_loongarch_cpucfg, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_csrrd, "UiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrrd, "ULiIULi", "nc")
+BUILTIN(__builtin_loongarch_csrwr, "UiUiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrwr, "ULiULiIULi", "nc")
+BUILTIN(__builtin_loongarch_csrxchg, "UiUiUiIUi", "nc")
+BUILTIN(__builtin_loongarch_dcsrxchg, "ULiULiULiIULi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_b, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_h, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_w, "UiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrrd_d, "ULiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_b, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_h, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_w, "vUiUi", "nc")
+BUILTIN(__builtin_loongarch_iocsrwr_d, "vULiUi", "nc")
+BUILTIN(__builtin_loongarch_cacop, "viUii", "nc")
+BUILTIN(__builtin_loongarch_dcacop, "viULiLi", "nc")
+BUILTIN(__builtin_loongarch_crc_w_b_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_h_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_w_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crc_w_d_w, "iLii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_b_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_h_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_w_w, "iii", "nc")
+BUILTIN(__builtin_loongarch_crcc_w_d_w, "iLii", "nc")
+BUILTIN(__builtin_loongarch_tlbclr, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbflush, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbfill, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbrd, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbwr, "v", "nc")
+BUILTIN(__builtin_loongarch_tlbsrch, "v", "nc")
+BUILTIN(__builtin_loongarch_syscall, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_break, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_asrtle_d, "vLiLi", "nc")
+BUILTIN(__builtin_loongarch_asrtgt_d, "vLiLi", "nc")
+BUILTIN(__builtin_loongarch_dbar, "vIULi", "nc")
+BUILTIN(__builtin_loongarch_ibar, "vIULi", "nc")
+#undef BUILTIN
diff --git a/clang/include/clang/Basic/TargetBuiltins.h b/clang/include/clang/Basic/TargetBuiltins.h
index b472547012f0..1a7029c05cb4 100644
--- a/clang/include/clang/Basic/TargetBuiltins.h
+++ b/clang/include/clang/Basic/TargetBuiltins.h
@@ -124,6 +124,16 @@ namespace clang {
   enum { LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1, LastTSBuiltin };
   }
 
+  /// LoongArch builtins
+  namespace LoongArch {
+  enum {
+    LastTIBuiltin = clang::Builtin::FirstTSBuiltin-1,
+#define BUILTIN(ID, TYPE, ATTRS) BI##ID,
+#include "clang/Basic/BuiltinsLoongArch.def"
+    LastTSBuiltin
+  };
+  } // namespace LoongArch
+
   /// Flags to identify the types for overloaded Neon builtins.
   ///
   /// These must be kept in sync with the flags in utils/TableGen/NeonEmitter.h.
@@ -326,7 +336,7 @@ namespace clang {
        NVPTX::LastTSBuiltin, AMDGPU::LastTSBuiltin, X86::LastTSBuiltin,
        Hexagon::LastTSBuiltin, Mips::LastTSBuiltin, XCore::LastTSBuiltin,
        Le64::LastTSBuiltin, SystemZ::LastTSBuiltin,
-       WebAssembly::LastTSBuiltin});
+       WebAssembly::LastTSBuiltin, LoongArch::LastTSBuiltin});
 
 } // end namespace clang.
 
diff --git a/clang/include/clang/Basic/TargetCXXABI.h b/clang/include/clang/Basic/TargetCXXABI.h
index 93f70fc70dd8..b0ea3e88be2f 100644
--- a/clang/include/clang/Basic/TargetCXXABI.h
+++ b/clang/include/clang/Basic/TargetCXXABI.h
@@ -88,6 +88,12 @@ public:
     ///   - representation of member function pointers adjusted as in ARM.
     GenericMIPS,
 
+    /// The generic LoongArch ABI is a modified version of the Itanium ABI.
+    ///
+    /// At the moment, only change from the generic ABI in this case is:
+    ///   - representation of member function pointers adjusted as in ARM.
+    GenericLoongArch,
+
     /// The WebAssembly ABI is a modified version of the Itanium ABI.
     ///
     /// The changes from the Itanium ABI are:
@@ -154,6 +160,7 @@ public:
     case iOS64:
     case WatchOS:
     case GenericMIPS:
+    case GenericLoongArch:
     case WebAssembly:
     case XL:
       return true;
@@ -175,6 +182,7 @@ public:
     case iOS64:
     case WatchOS:
     case GenericMIPS:
+    case GenericLoongArch:
     case WebAssembly:
     case XL:
       return false;
@@ -203,6 +211,7 @@ public:
     case GenericARM:
     case GenericAArch64:
     case GenericMIPS:
+    case GenericLoongArch:
       // TODO: ARM-style pointers to member functions put the discriminator in
       //       the this adjustment, so they don't require functions to have any
       //       special alignment and could therefore also return false.
@@ -288,6 +297,7 @@ public:
     case iOS:   // old iOS compilers did not follow this rule
     case Microsoft:
     case GenericMIPS:
+    case GenericLoongArch:
     case XL:
       return true;
     }
@@ -326,6 +336,7 @@ public:
     case GenericARM:
     case iOS:
     case GenericMIPS:
+    case GenericLoongArch:
     case XL:
       return UseTailPaddingUnlessPOD03;
 
diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index 966cb907b7e2..cb545a652138 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -159,6 +159,8 @@ def m_x86_Features_Group : OptionGroup<"<x86 features group>">,
                            Group<m_Group>, Flags<[CoreOption]>, DocName<"X86">;
 def m_riscv_Features_Group : OptionGroup<"<riscv features group>">,
                              Group<m_Group>, DocName<"RISCV">;
+def m_loongarch_Features_Group : OptionGroup<"<loongarch features group>">,
+                                 Group<m_Group>, DocName<"LoongArch">;
 
 def m_libc_Group : OptionGroup<"<m libc group>">, Group<m_mips_Features_Group>,
                    Flags<[HelpHidden]>;
@@ -3070,6 +3072,13 @@ def mnvs : Flag<["-"], "mnvs">, Group<m_hexagon_Features_Group>,
 def mno_nvs : Flag<["-"], "mno-nvs">, Group<m_hexagon_Features_Group>,
   Flags<[CC1Option]>, HelpText<"Disable generation of new-value stores">;
 
+// LoongArch features flags
+def mfix_loongson3_llsc : Flag<["-"], "mfix-loongson3-llsc">,
+    Group<m_loongarch_Features_Group>,
+    HelpText<"Workaround loongson3 llsc erratum (LoongArch only)">;
+def mno_fix_loongson3_llsc : Flag<["-"], "mno-fix-loongson3-llsc">,
+    Group<m_loongarch_Features_Group>,
+    HelpText<"Don't Workaround loongson3 llsc erratum (LoongArch only)">;
 
 // X86 feature flags
 def mx87 : Flag<["-"], "mx87">, Group<m_x86_Features_Group>;
diff --git a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
index 6f7ad8076718..716b4faa31d9 100644
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -12141,6 +12141,9 @@ private:
   bool CheckBPFBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);
   bool CheckHexagonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);
   bool CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);
+  bool CheckLoongArchBuiltinFunctionCall(const TargetInfo &TI,
+                                         unsigned BuiltinID,
+                                         CallExpr *TheCall);
   bool CheckMipsBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,
                                     CallExpr *TheCall);
   bool CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,
diff --git a/clang/include/clang/module.modulemap b/clang/include/clang/module.modulemap
index 13d4dbf9dc2e..c55b43841435 100644
--- a/clang/include/clang/module.modulemap
+++ b/clang/include/clang/module.modulemap
@@ -41,6 +41,7 @@ module Clang_Basic {
   textual header "Basic/BuiltinsHexagonDep.def"
   textual header "Basic/BuiltinsHexagonMapCustomDep.def"
   textual header "Basic/BuiltinsLe64.def"
+  textual header "Basic/BuiltinsLoongArch.def"
   textual header "Basic/BuiltinsMips.def"
   textual header "Basic/BuiltinsNEON.def"
   textual header "Basic/BuiltinsNVPTX.def"
diff --git a/clang/lib/AST/ASTContext.cpp b/clang/lib/AST/ASTContext.cpp
index bf51d35d9693..266225fd9698 100644
--- a/clang/lib/AST/ASTContext.cpp
+++ b/clang/lib/AST/ASTContext.cpp
@@ -889,6 +889,7 @@ CXXABI *ASTContext::createCXXABI(const TargetInfo &T) {
   case TargetCXXABI::iOS64:
   case TargetCXXABI::WatchOS:
   case TargetCXXABI::GenericAArch64:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::WebAssembly:
@@ -10740,6 +10741,7 @@ MangleContext *ASTContext::createMangleContext(const TargetInfo *T) {
   case TargetCXXABI::GenericAArch64:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::GenericARM:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::iOS:
   case TargetCXXABI::iOS64:
diff --git a/clang/lib/Basic/CMakeLists.txt b/clang/lib/Basic/CMakeLists.txt
index 1b55d8417377..a81e50f18504 100644
--- a/clang/lib/Basic/CMakeLists.txt
+++ b/clang/lib/Basic/CMakeLists.txt
@@ -73,6 +73,7 @@ add_clang_library(clangBasic
   Targets/Hexagon.cpp
   Targets/Lanai.cpp
   Targets/Le64.cpp
+  Targets/LoongArch.cpp
   Targets/MSP430.cpp
   Targets/Mips.cpp
   Targets/NVPTX.cpp
diff --git a/clang/lib/Basic/Targets.cpp b/clang/lib/Basic/Targets.cpp
index 965f273892bd..1f009c1d7fd1 100644
--- a/clang/lib/Basic/Targets.cpp
+++ b/clang/lib/Basic/Targets.cpp
@@ -22,6 +22,7 @@
 #include "Targets/Hexagon.h"
 #include "Targets/Lanai.h"
 #include "Targets/Le64.h"
+#include "Targets/LoongArch.h"
 #include "Targets/MSP430.h"
 #include "Targets/Mips.h"
 #include "Targets/NVPTX.h"
@@ -314,6 +315,25 @@ TargetInfo *AllocateTarget(const llvm::Triple &Triple,
   case llvm::Triple::le64:
     return new Le64TargetInfo(Triple, Opts);
 
+#if 0
+  //TODO: support it in future
+  case llvm::Triple::loongarch32:
+    switch (os) {
+    case llvm::Triple::Linux:
+      return new LinuxTargetInfo<LoongArchTargetInfo>(Triple, Opts);
+    default:
+      return new LoongArchTargetInfo(Triple, Opts);
+    }
+#endif
+
+  case llvm::Triple::loongarch64:
+    switch (os) {
+    case llvm::Triple::Linux:
+      return new LinuxTargetInfo<LoongArchTargetInfo>(Triple, Opts);
+    default:
+      return new LoongArchTargetInfo(Triple, Opts);
+    }
+
   case llvm::Triple::ppc:
     if (Triple.isOSDarwin())
       return new DarwinPPC32TargetInfo(Triple, Opts);
diff --git a/clang/lib/Basic/Targets/LoongArch.cpp b/clang/lib/Basic/Targets/LoongArch.cpp
new file mode 100644
index 000000000000..10b05bf98282
--- /dev/null
+++ b/clang/lib/Basic/Targets/LoongArch.cpp
@@ -0,0 +1,174 @@
+//===--- LoongArch.cpp - Implement LoongArch target feature support -----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements LoongArch TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#include "LoongArch.h"
+#include "Targets.h"
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/MacroBuilder.h"
+#include "clang/Basic/TargetBuiltins.h"
+#include "llvm/ADT/StringSwitch.h"
+
+using namespace clang;
+using namespace clang::targets;
+
+const Builtin::Info LoongArchTargetInfo::BuiltinInfo[] = {
+#define BUILTIN(ID, TYPE, ATTRS)                                               \
+  {#ID, TYPE, ATTRS, nullptr, ALL_LANGUAGES, nullptr},
+#define LIBBUILTIN(ID, TYPE, ATTRS, HEADER)                                    \
+  {#ID, TYPE, ATTRS, HEADER, ALL_LANGUAGES, nullptr},
+#include "clang/Basic/BuiltinsLoongArch.def"
+};
+
+bool LoongArchTargetInfo::processorSupportsGPR64() const {
+  return llvm::StringSwitch<bool>(CPU)
+      .Case("la464", true)
+      .Default(false);
+  return false;
+}
+
+static constexpr llvm::StringLiteral ValidCPUNames[] = {
+    {"la464"}
+};
+
+bool LoongArchTargetInfo::isValidCPUName(StringRef Name) const {
+  return llvm::find(ValidCPUNames, Name) != std::end(ValidCPUNames);
+}
+
+void LoongArchTargetInfo::fillValidCPUList(
+    SmallVectorImpl<StringRef> &Values) const {
+  Values.append(std::begin(ValidCPUNames), std::end(ValidCPUNames));
+}
+
+void LoongArchTargetInfo::getTargetDefines(const LangOptions &Opts,
+                                      MacroBuilder &Builder) const {
+  Builder.defineMacro("__loongarch__");
+
+  if (ABI == "lp32") {
+    Builder.defineMacro("__loongarch32");
+  } else {
+    Builder.defineMacro("__loongarch64");
+  }
+
+  //TODO: support others ABIs
+  if (ABI == "lp64d") {
+    Builder.defineMacro("__loongarch_lp64");
+  }
+
+  if (ABI == "lp32") {
+    Builder.defineMacro("_ABILP32", "1");
+  } else if (ABI == "lpx32") {
+    Builder.defineMacro("_ABILPX32", "2");
+  } else if (ABI == "lp64d") {
+    Builder.defineMacro("_ABILP64", "3");
+    Builder.defineMacro("_LOONGARCH_SIM", "_ABILP64");
+  } else
+    llvm_unreachable("Invalid ABI.");
+
+  Builder.defineMacro("__REGISTER_PREFIX__", "");
+
+  switch (FloatABI) {
+  case HardFloat:
+    Builder.defineMacro("__loongarch_hard_float", Twine(1));
+    break;
+  case SoftFloat:
+    Builder.defineMacro("__loongarch_soft_float", Twine(1));
+    break;
+  }
+
+  if (IsSingleFloat)
+    Builder.defineMacro("__loongarch_single_float", Twine(1));
+
+  switch (FPMode) {
+  case FP32:
+    Builder.defineMacro("__loongarch_fpr", Twine(32));
+    break;
+  case FP64:
+    Builder.defineMacro("__loongarch_fpr", Twine(64));
+    break;
+  }
+
+  Builder.defineMacro("_LOONGARCH_SZPTR", Twine(getPointerWidth(0)));
+  Builder.defineMacro("_LOONGARCH_SZINT", Twine(getIntWidth()));
+  Builder.defineMacro("_LOONGARCH_SZLONG", Twine(getLongWidth()));
+
+  Builder.defineMacro("_LOONGARCH_ARCH", "\"" + CPU + "\"");
+  Builder.defineMacro("_LOONGARCH_ARCH_" + StringRef(CPU).upper());
+
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1");
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2");
+  Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4");
+
+  // 32-bit loongarch processors don't have the necessary lld/scd instructions
+  // found in 64-bit processors. In the case of lp32 on a 64-bit processor,
+  // the instructions exist but using them violates the ABI since they
+  // require 64-bit GPRs and LP32 only supports 32-bit GPRs.
+  if (ABI == "lpx32" || ABI == "lp64d")
+    Builder.defineMacro("__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8");
+}
+
+bool LoongArchTargetInfo::hasFeature(StringRef Feature) const {
+  return llvm::StringSwitch<bool>(Feature)
+      .Case("fp64", FPMode == FP64)
+      .Default(false);
+}
+
+ArrayRef<Builtin::Info> LoongArchTargetInfo::getTargetBuiltins() const {
+  return llvm::makeArrayRef(BuiltinInfo, clang::LoongArch::LastTSBuiltin -
+                                             Builtin::FirstTSBuiltin);
+}
+
+bool LoongArchTargetInfo::validateTarget(DiagnosticsEngine &Diags) const {
+  // FIXME: It's valid to use LP32 on a 64-bit CPU but the backend can't handle
+  //        this yet. It's better to fail here than on the backend assertion.
+  if (processorSupportsGPR64() && ABI == "lp32") {
+    Diags.Report(diag::err_target_unsupported_abi) << ABI << CPU;
+    return false;
+  }
+
+  // 64-bit ABI's require 64-bit CPU's.
+  if (!processorSupportsGPR64() && (ABI == "lpx32" || ABI == "lp64d")) {
+    Diags.Report(diag::err_target_unsupported_abi) << ABI << CPU;
+    return false;
+  }
+
+  // FIXME: It's valid to use lp32 on a loongarch64 triple but the backend
+  //        can't handle this yet. It's better to fail here than on the
+  //        backend assertion.
+  if (getTriple().isLoongArch64() && ABI == "lp32") {
+    Diags.Report(diag::err_target_unsupported_abi_for_triple)
+        << ABI << getTriple().str();
+    return false;
+  }
+
+  // FIXME: It's valid to use lpx32/lp64d on a loongarch32 triple but the backend
+  //        can't handle this yet. It's better to fail here than on the
+  //        backend assertion.
+  if (getTriple().isLoongArch32() && (ABI == "lpx32" || ABI == "lp64d")) {
+    Diags.Report(diag::err_target_unsupported_abi_for_triple)
+        << ABI << getTriple().str();
+    return false;
+  }
+
+  // -mfp32 and lpx32/lp64d ABIs are incompatible
+  if (FPMode != FP64 && !IsSingleFloat &&
+      (ABI == "lpx32"  || ABI == "lp64d")) {
+    Diags.Report(diag::err_opt_not_valid_with_opt) << "-mfp32" << ABI;
+    return false;
+  }
+
+  if (FPMode != FP64 && (CPU == "la464")) {
+    Diags.Report(diag::err_opt_not_valid_with_opt) << "-mfp32" << CPU;
+    return false;
+  }
+
+  return true;
+}
diff --git a/clang/lib/Basic/Targets/LoongArch.h b/clang/lib/Basic/Targets/LoongArch.h
new file mode 100644
index 000000000000..cba15694fb1e
--- /dev/null
+++ b/clang/lib/Basic/Targets/LoongArch.h
@@ -0,0 +1,382 @@
+//===--- LoongArch.h - Declare LoongArch target feature support -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares LoongArch TargetInfo objects.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
+#define LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
+
+#include "clang/Basic/TargetInfo.h"
+#include "clang/Basic/TargetOptions.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Support/Compiler.h"
+
+namespace clang {
+namespace targets {
+
+class LLVM_LIBRARY_VISIBILITY LoongArchTargetInfo : public TargetInfo {
+  void setDataLayout() {
+    StringRef Layout;
+
+    if (ABI == "lp32")
+      Layout = "m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64";
+    else if (ABI == "lpx32")
+      Layout = "m:e-p:32:32-i8:8:32-i16:16:32-i64:64-n32:64-S128";
+    else if (ABI == "lp64d")
+      Layout = "m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128";
+    else
+      llvm_unreachable("Invalid ABI");
+
+    resetDataLayout(("e-" + Layout).str());
+  }
+
+  static const Builtin::Info BuiltinInfo[];
+  std::string CPU;
+  bool IsSingleFloat;
+  enum LoongArchFloatABI { HardFloat, SoftFloat } FloatABI;
+
+protected:
+  enum FPModeEnum { FP32, FP64 } FPMode;
+  std::string ABI;
+
+public:
+  LoongArchTargetInfo(const llvm::Triple &Triple, const TargetOptions &)
+      : TargetInfo(Triple),
+        IsSingleFloat(false),
+        FloatABI(HardFloat),
+        FPMode(FP64) {
+    TheCXXABI.set(TargetCXXABI::GenericLoongArch);
+
+    if (Triple.isLoongArch32())
+      setABI("lp32");
+    else
+      setABI("lp64d");
+
+    // Currently, CPU only supports 'la464' in LA.
+    if ( ABI == "lp64d")
+      CPU = "la464";
+  }
+
+  bool processorSupportsGPR64() const;
+
+  StringRef getABI() const override { return ABI; }
+
+  bool setABI(const std::string &Name) override {
+    if (Name == "lp32") {
+      setLP32ABITypes();
+      ABI = Name;
+      return true;
+    }
+
+    if (Name == "lpx32") {
+      //setLPX32ABITypes();
+      //ABI = Name;
+      //return true;
+      //TODO: implement
+      return false;
+    }
+    if (Name == "lp64d") {
+      setLP64ABITypes();
+      ABI = Name;
+      return true;
+    }
+    return false;
+  }
+
+  void setLP32ABITypes() {
+    Int64Type = SignedLongLong;
+    IntMaxType = Int64Type;
+    LongDoubleFormat = &llvm::APFloat::IEEEdouble();
+    LongDoubleWidth = LongDoubleAlign = 64;
+    LongWidth = LongAlign = 32;
+    MaxAtomicPromoteWidth = MaxAtomicInlineWidth = 32;
+    PointerWidth = PointerAlign = 32;
+    PtrDiffType = SignedInt;
+    SizeType = UnsignedInt;
+    SuitableAlign = 64;
+  }
+
+  void setLPX32LP64ABITypes() {
+    LongDoubleWidth = LongDoubleAlign = 128;
+    LongDoubleFormat = &llvm::APFloat::IEEEquad();
+    if (getTriple().isOSFreeBSD()) {
+      LongDoubleWidth = LongDoubleAlign = 64;
+      LongDoubleFormat = &llvm::APFloat::IEEEdouble();
+    }
+    MaxAtomicPromoteWidth = MaxAtomicInlineWidth = 64;
+    SuitableAlign = 128;
+  }
+
+  void setLP64ABITypes() {
+    setLPX32LP64ABITypes();
+    if (getTriple().isOSOpenBSD()) {
+      Int64Type = SignedLongLong;
+    } else {
+      Int64Type = SignedLong;
+    }
+    IntMaxType = Int64Type;
+    LongWidth = LongAlign = 64;
+    PointerWidth = PointerAlign = 64;
+    PtrDiffType = SignedLong;
+    SizeType = UnsignedLong;
+  }
+
+  void setLPX32ABITypes() {
+    setLPX32LP64ABITypes();
+    Int64Type = SignedLongLong;
+    IntMaxType = Int64Type;
+    LongWidth = LongAlign = 32;
+    PointerWidth = PointerAlign = 32;
+    PtrDiffType = SignedInt;
+    SizeType = UnsignedInt;
+  }
+
+  bool isValidCPUName(StringRef Name) const override;
+  void fillValidCPUList(SmallVectorImpl<StringRef> &Values) const override;
+
+  bool setCPU(const std::string &Name) override {
+    CPU = Name;
+    return isValidCPUName(Name);
+  }
+
+  const std::string &getCPU() const { return CPU; }
+  bool
+  initFeatureMap(llvm::StringMap<bool> &Features, DiagnosticsEngine &Diags,
+                 StringRef CPU,
+                 const std::vector<std::string> &FeaturesVec) const override {
+#if 0
+    if (CPU.empty())
+      CPU = getCPU();
+    Features[CPU] = true;
+#else
+//    if (CPU == "la464")
+//      Features["loongarch64"] = true;
+
+//FIXME: we need this?
+//    if (CPU == "la464")
+//      Features["64bit"] = true;
+#endif
+    return TargetInfo::initFeatureMap(Features, Diags, CPU, FeaturesVec);
+  }
+
+  void getTargetDefines(const LangOptions &Opts,
+                        MacroBuilder &Builder) const override;
+
+  ArrayRef<Builtin::Info> getTargetBuiltins() const override;
+
+  bool hasFeature(StringRef Feature) const override;
+
+  BuiltinVaListKind getBuiltinVaListKind() const override {
+    return TargetInfo::VoidPtrBuiltinVaList;
+  }
+
+  ArrayRef<const char *> getGCCRegNames() const override {
+    static const char *const GCCRegNames[] = {
+        // CPU register names
+        // Must match second column of GCCRegAliases
+        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9", "$r10",
+        "$r11", "$r12", "$r13", "$r14", "$r15", "$r16", "$r17", "$r18", "$r19", "$r20",
+        "$r21", "$r22", "$r23", "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30",
+        "$r31",
+        // Floating point register names
+        "$f0", "$f1", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7", "$f8", "$f9",
+        "$f10", "$f11", "$f12", "$f13", "$f14", "$f15", "$f16", "$f17", "$f18",
+        "$f19", "$f20", "$f21", "$f22", "$f23", "$f24", "$f25", "$f26", "$f27",
+        "$f28", "$f29", "$f30", "$f31",
+        // condition register names
+        "$fcc0", "$fcc1", "$fcc2", "$fcc3", "$fcc4", "$fcc5", "$fcc6", "$fcc7"
+    };
+    return llvm::makeArrayRef(GCCRegNames);
+  }
+
+  bool validateAsmConstraint(const char *&Name,
+                             TargetInfo::ConstraintInfo &Info) const override {
+    switch (*Name) {
+    default:
+      return false;
+    case 'r': // CPU registers.
+    case 'f': // floating-point registers.
+      Info.setAllowsRegister();
+      return true;
+    case 'l': // Signed 16-bit constant
+    case 'I': // Signed 12-bit constant
+    case 'K': // Unsigned 12-bit constant
+    case 'J': // Integer 0
+    case 'G': // Floating-point 0
+      return true;
+    case 'm': // Memory address with 12-bit offset
+    case 'R': // An address that can be used in a non-macro load or store
+      Info.setAllowsMemory();
+      return true;
+    case 'Z':
+      if (Name[1] == 'C'        // Memory address with 16-bit and 4 bytes aligned offset
+          || Name[1] == 'B' ) { // Memory address with 0 offset
+        Info.setAllowsMemory();
+        Name++; // Skip over 'Z'.
+        return true;
+      }
+      return false;
+    }
+  }
+
+  std::string convertConstraint(const char *&Constraint) const override {
+    std::string R;
+    switch (*Constraint) {
+    case 'Z': // Two-character constraint; add "^" hint for later parsing.
+      if (Constraint[1] == 'C' || Constraint[1] == 'B') {
+        R = std::string("^") + std::string(Constraint, 2);
+        Constraint++;
+        return R;
+      }
+      break;
+    }
+    return TargetInfo::convertConstraint(Constraint);
+  }
+
+  const char *getClobbers() const override {
+#if 0
+    // In GCC, $1 is not widely used in generated code (it's used only in a few
+    // specific situations), so there is no real need for users to add it to
+    // the clobbers list if they want to use it in their inline assembly code.
+    //
+    // In LLVM, $1 is treated as a normal GPR and is always allocatable during
+    // code generation, so using it in inline assembly without adding it to the
+    // clobbers list can cause conflicts between the inline assembly code and
+    // the surrounding generated code.
+    //
+    // Another problem is that LLVM is allowed to choose $1 for inline assembly
+    // operands, which will conflict with the ".set at" assembler option (which
+    // we use only for inline assembly, in order to maintain compatibility with
+    // GCC) and will also conflict with the user's usage of $1.
+    //
+    // The easiest way to avoid these conflicts and keep $1 as an allocatable
+    // register for generated code is to automatically clobber $1 for all inline
+    // assembly code.
+    //
+    // FIXME: We should automatically clobber $1 only for inline assembly code
+    // which actually uses it. This would allow LLVM to use $1 for inline
+    // assembly operands if the user's assembly code doesn't use it.
+    return "~{$1}";
+#endif
+    return "";
+  }
+
+  bool handleTargetFeatures(std::vector<std::string> &Features,
+                            DiagnosticsEngine &Diags) override {
+    IsSingleFloat = false;
+    FloatABI = HardFloat;
+    FPMode = FP64;
+
+    for (const auto &Feature : Features) {
+      if (Feature == "+single-float")
+        IsSingleFloat = true;
+      else if (Feature == "+soft-float")
+        FloatABI = SoftFloat;
+      else if (Feature == "+fp64")
+        FPMode = FP64;
+      else if (Feature == "-fp64")
+        FPMode = FP32;
+    }
+
+    setDataLayout();
+
+    return true;
+  }
+
+  int getEHDataRegisterNumber(unsigned RegNo) const override {
+    if (RegNo == 0)
+      return 4;
+    if (RegNo == 1)
+      return 5;
+    return -1;
+  }
+
+  bool isCLZForZeroUndef() const override { return false; }
+
+  ArrayRef<TargetInfo::GCCRegAlias> getGCCRegAliases() const override {
+    static const TargetInfo::GCCRegAlias GCCRegAliases[] = {
+        {{"zero", "$zero", "r0", "$0"}, "$r0"},
+        {{"ra", "$ra", "r1", "$1"}, "$r1"},
+        {{"tp", "$tp", "r2", "$2"}, "$r2"},
+        {{"sp", "$sp", "r3", "$3"}, "$r3"},
+        {{"a0", "$a0", "r4", "$4", "v0"}, "$r4"},
+        {{"a1", "$a1", "r5", "$5", "v1"}, "$r5"},
+        {{"a2", "$a2", "r6", "$6"}, "$r6"},
+        {{"a3", "$a3", "r7", "$7"}, "$r7"},
+        {{"a4", "$a4", "r8", "$8"}, "$r8"},
+        {{"a5", "$a5", "r9", "$9"}, "$r9"},
+        {{"a6", "$a6", "r10", "$10"}, "$r10"},
+        {{"a7", "$a7", "r11", "$11"}, "$r11"},
+        {{"t0", "$t0", "r12", "$12"}, "$r12"},
+        {{"t1", "$t1", "r13", "$13"}, "$r13"},
+        {{"t2", "$t2", "r14", "$14"}, "$r14"},
+        {{"t3", "$t3", "r15", "$15"}, "$r15"},
+        {{"t4", "$t4", "r16", "$16"}, "$r16"},
+        {{"t5", "$t5", "r17", "$17"}, "$r17"},
+        {{"t6", "$t6", "r18", "$18"}, "$r18"},
+        {{"t7", "$t7", "r19", "$19"}, "$r19"},
+        {{"t8", "$t8", "r20", "$20"}, "$r20"},
+        //{{"x", "$x", "r21", "$21"}, "$r21"},
+        {{"fp", "$fp", "r22", "$22"}, "$r22"},
+        {{"s0", "$s0", "r23", "$23"}, "$r23"},
+        {{"s1", "$s1", "r24", "$24"}, "$r24"},
+        {{"s2", "$s2", "r25", "$25"}, "$r25"},
+        {{"s3", "$s3", "r26", "$26"}, "$r26"},
+        {{"s4", "$s4", "r27", "$27"}, "$r27"},
+        {{"s5", "$s5", "r28", "$28"}, "$r28"},
+        {{"s6", "$s6", "r29", "$29"}, "$r29"},
+        {{"s7", "$s7", "r30", "$30"}, "$r30"},
+        {{"s8", "$s8", "r31", "$31"}, "$r31"},
+        {{"fa0", "$fa0", "f0"}, "$f0"},
+        {{"fa1", "$fa1", "f1"}, "$f1"},
+        {{"fa2", "$fa2", "f2"}, "$f2"},
+        {{"fa3", "$fa3", "f3"}, "$f3"},
+        {{"fa4", "$fa4", "f4"}, "$f4"},
+        {{"fa5", "$fa5", "f5"}, "$f5"},
+        {{"fa6", "$fa6", "f6"}, "$f6"},
+        {{"fa7", "$fa7", "f7"}, "$f7"},
+        {{"ft0", "$ft0", "f8"}, "$f8"},
+        {{"ft1", "$ft1", "f9"}, "$f9"},
+        {{"ft2", "$ft2", "f10"}, "$f10"},
+        {{"ft3", "$ft3", "f11"}, "$f11"},
+        {{"ft4", "$ft4", "f12"}, "$f12"},
+        {{"ft5", "$ft5", "f13"}, "$f13"},
+        {{"ft6", "$ft6", "f14"}, "$f14"},
+        {{"ft7", "$ft7", "f15"}, "$f15"},
+        {{"ft8", "$ft8", "f16"}, "$f16"},
+        {{"ft9", "$ft9", "f17"}, "$f17"},
+        {{"ft10", "$ft10", "f18"}, "$f18"},
+        {{"ft11", "$ft11", "f19"}, "$f19"},
+        {{"ft12", "$ft12", "f20"}, "$f20"},
+        {{"ft13", "$ft13", "f21"}, "$f21"},
+        {{"ft14", "$ft14", "f22"}, "$f22"},
+        {{"ft15", "$ft15", "f23"}, "$f23"},
+        {{"fs0", "$fs0", "f24"}, "$f24"},
+        {{"fs1", "$fs1", "f25"}, "$f25"},
+        {{"fs2", "$fs2", "f26"}, "$f26"},
+        {{"fs3", "$fs3", "f27"}, "$f27"},
+        {{"fs4", "$fs4", "f28"}, "$f28"},
+        {{"fs5", "$fs5", "f29"}, "$f29"},
+        {{"fs6", "$fs6", "f30"}, "$f30"},
+        {{"fs7", "$fs7", "f31"}, "$f31"},
+    };
+    return llvm::makeArrayRef(GCCRegAliases);
+  }
+
+  bool hasInt128Type() const override {
+    return (ABI == "lpx32" || ABI == "lp64d") || getTargetOpts().ForceEnableInt128;
+  }
+
+  bool validateTarget(DiagnosticsEngine &Diags) const override;
+};
+} // namespace targets
+} // namespace clang
+
+#endif // LLVM_CLANG_LIB_BASIC_TARGETS_LOONGARCH_H
diff --git a/clang/lib/CodeGen/CodeGenModule.cpp b/clang/lib/CodeGen/CodeGenModule.cpp
index 4ae8ce7e5ccf..50346a1932df 100644
--- a/clang/lib/CodeGen/CodeGenModule.cpp
+++ b/clang/lib/CodeGen/CodeGenModule.cpp
@@ -81,6 +81,7 @@ static CGCXXABI *createCXXABI(CodeGenModule &CGM) {
   case TargetCXXABI::iOS:
   case TargetCXXABI::iOS64:
   case TargetCXXABI::WatchOS:
+  case TargetCXXABI::GenericLoongArch:
   case TargetCXXABI::GenericMIPS:
   case TargetCXXABI::GenericItanium:
   case TargetCXXABI::WebAssembly:
diff --git a/clang/lib/CodeGen/ItaniumCXXABI.cpp b/clang/lib/CodeGen/ItaniumCXXABI.cpp
index 80de2a6e3950..c981605d1f2a 100644
--- a/clang/lib/CodeGen/ItaniumCXXABI.cpp
+++ b/clang/lib/CodeGen/ItaniumCXXABI.cpp
@@ -563,6 +563,9 @@ CodeGen::CGCXXABI *CodeGen::CreateItaniumCXXABI(CodeGenModule &CGM) {
     return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true,
                              /*UseARMGuardVarABI=*/true);
 
+  case TargetCXXABI::GenericLoongArch:
+    return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true);
+
   case TargetCXXABI::GenericMIPS:
     return new ItaniumCXXABI(CGM, /*UseARMMethodPtrABI=*/true);
 
diff --git a/clang/lib/CodeGen/TargetInfo.cpp b/clang/lib/CodeGen/TargetInfo.cpp
index 9cd63ebe29ee..3ae2366ba5d8 100644
--- a/clang/lib/CodeGen/TargetInfo.cpp
+++ b/clang/lib/CodeGen/TargetInfo.cpp
@@ -7560,6 +7560,540 @@ void MSP430TargetCodeGenInfo::setTargetAttributes(
   }
 }
 
+//===----------------------------------------------------------------------===//
+// LoongArch ABI Implementation
+//===----------------------------------------------------------------------===//
+
+namespace {
+class LoongArchABIInfo : public DefaultABIInfo {
+private:
+  // Size of the integer ('r') registers in bits.
+  unsigned GRLen;
+  // Size of the floating point ('f') registers in bits. Note that the target
+  // ISA might have a wider FRLen than the selected ABI.
+  unsigned FRLen;
+  static const int NumArgGPRs = 8;
+  static const int NumArgFPRs = 8;
+  bool detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,
+                                      llvm::Type *&Field1Ty,
+                                      CharUnits &Field1Off,
+                                      llvm::Type *&Field2Ty,
+                                      CharUnits &Field2Off) const;
+
+public:
+  LoongArchABIInfo(CodeGen::CodeGenTypes &CGT, unsigned GRLen, unsigned FRLen)
+      : DefaultABIInfo(CGT), GRLen(GRLen), FRLen(FRLen) {}
+
+  // DefaultABIInfo's classifyReturnType and classifyArgumentType are
+  // non-virtual, but computeInfo is virtual, so we overload it.
+  void computeInfo(CGFunctionInfo &FI) const override;
+
+  ABIArgInfo classifyArgumentType(QualType Ty, bool IsFixed, int &ArgGPRsLeft,
+                                  int &ArgFPRsLeft) const;
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+
+  uint64_t MinABIStackAlignInBytes = 8;
+  uint64_t StackAlignInBytes = 16;
+  llvm::Type* HandleAggregates(QualType Ty, uint64_t TySize) const;
+  llvm::Type* getPaddingType(uint64_t Align, uint64_t Offset) const;
+  void CoerceToIntArgs(uint64_t TySize,
+                       SmallVectorImpl<llvm::Type *> &ArgList) const;
+
+  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                    QualType Ty) const override;
+
+  ABIArgInfo extendType(QualType Ty) const;
+
+  bool detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,
+                                CharUnits &Field1Off, llvm::Type *&Field2Ty,
+                                CharUnits &Field2Off, int &NeededArgGPRs,
+                                int &NeededArgFPRs) const;
+  ABIArgInfo coerceAndExpandFPCCEligibleStruct(llvm::Type *Field1Ty,
+                                               CharUnits Field1Off,
+                                               llvm::Type *Field2Ty,
+                                               CharUnits Field2Off) const;
+};
+} // end anonymous namespace
+
+void LoongArchABIInfo::computeInfo(CGFunctionInfo &FI) const {
+  QualType RetTy = FI.getReturnType();
+  if (!getCXXABI().classifyReturnType(FI))
+    FI.getReturnInfo() = classifyReturnType(RetTy);
+
+  // IsRetIndirect is true if classifyArgumentType indicated the value should
+  // be passed indirect or if the type size is greater than 2*grlen.
+  bool IsRetIndirect = FI.getReturnInfo().getKind() == ABIArgInfo::Indirect ||
+                       getContext().getTypeSize(RetTy) > (2 * GRLen);
+
+  // We must track the number of GPRs used in order to conform to the LoongArch
+  // ABI, as integer scalars passed in registers should have signext/zeroext
+  // when promoted, but are anyext if passed on the stack. As GPR usage is
+  // different for variadic arguments, we must also track whether we are
+  // examining a vararg or not.
+  int ArgGPRsLeft = IsRetIndirect ? NumArgGPRs - 1 : NumArgGPRs;
+  int ArgFPRsLeft = FRLen ? NumArgFPRs : 0;
+  int NumFixedArgs = FI.getNumRequiredArgs();
+
+  int ArgNum = 0;
+  for (auto &ArgInfo : FI.arguments()) {
+    bool IsFixed = ArgNum < NumFixedArgs;
+    ArgInfo.info =
+        classifyArgumentType(ArgInfo.type, IsFixed, ArgGPRsLeft, ArgFPRsLeft);
+    ArgNum++;
+  }
+}
+
+// Returns true if the struct is a potential candidate for the floating point
+// calling convention. If this function returns true, the caller is
+// responsible for checking that if there is only a single field then that
+// field is a float.
+bool LoongArchABIInfo::detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,
+                                                  llvm::Type *&Field1Ty,
+                                                  CharUnits &Field1Off,
+                                                  llvm::Type *&Field2Ty,
+                                                  CharUnits &Field2Off) const {
+  bool IsInt = Ty->isIntegralOrEnumerationType();
+  bool IsFloat = Ty->isRealFloatingType();
+
+  if (IsInt || IsFloat) {
+    uint64_t Size = getContext().getTypeSize(Ty);
+    if (IsInt && Size > GRLen)
+      return false;
+    // Can't be eligible if larger than the FP registers. Half precision isn't
+    // currently supported on LoongArch and the ABI hasn't been confirmed, so
+    // default to the integer ABI in that case.
+    if (IsFloat && (Size > FRLen || Size < 32))
+      return false;
+    // Can't be eligible if an integer type was already found (int+int pairs
+    // are not eligible).
+    if (IsInt && Field1Ty && Field1Ty->isIntegerTy())
+      return false;
+    if (!Field1Ty) {
+      Field1Ty = CGT.ConvertType(Ty);
+      Field1Off = CurOff;
+      return true;
+    }
+    if (!Field2Ty) {
+      Field2Ty = CGT.ConvertType(Ty);
+      Field2Off = CurOff;
+      return true;
+    }
+    return false;
+  }
+
+  if (auto CTy = Ty->getAs<ComplexType>()) {
+    if (Field1Ty)
+      return false;
+    QualType EltTy = CTy->getElementType();
+    if (getContext().getTypeSize(EltTy) > FRLen)
+      return false;
+    Field1Ty = CGT.ConvertType(EltTy);
+    Field1Off = CurOff;
+    assert(CurOff.isZero() && "Unexpected offset for first field");
+    Field2Ty = Field1Ty;
+    Field2Off = Field1Off + getContext().getTypeSizeInChars(EltTy);
+    return true;
+  }
+
+  if (const ConstantArrayType *ATy = getContext().getAsConstantArrayType(Ty)) {
+    uint64_t ArraySize = ATy->getSize().getZExtValue();
+    QualType EltTy = ATy->getElementType();
+    CharUnits EltSize = getContext().getTypeSizeInChars(EltTy);
+    for (uint64_t i = 0; i < ArraySize; ++i) {
+      bool Ret = detectFPCCEligibleStructHelper(EltTy, CurOff, Field1Ty,
+                                                Field1Off, Field2Ty, Field2Off);
+      if (!Ret)
+        return false;
+      CurOff += EltSize;
+    }
+    return true;
+  }
+
+  if (const auto *RTy = Ty->getAs<RecordType>()) {
+    // Structures with either a non-trivial destructor or a non-trivial
+    // copy constructor are not eligible for the FP calling convention.
+    if (getRecordArgABI(Ty, CGT.getCXXABI()))
+      return false;
+    if (isEmptyRecord(getContext(), Ty, true))
+      return true;
+    const RecordDecl *RD = RTy->getDecl();
+    // Unions aren't eligible unless they're empty (which is caught above).
+    if (RD->isUnion())
+      return false;
+    int ZeroWidthBitFieldCount = 0;
+    for (const FieldDecl *FD : RD->fields()) {
+      const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);
+      uint64_t FieldOffInBits = Layout.getFieldOffset(FD->getFieldIndex());
+      QualType QTy = FD->getType();
+      if (FD->isBitField()) {
+        unsigned BitWidth = FD->getBitWidthValue(getContext());
+        // Allow a bitfield with a type greater than GRLen as long as the
+        // bitwidth is GRLen or less.
+        if (getContext().getTypeSize(QTy) > GRLen && BitWidth <= GRLen)
+          QTy = getContext().getIntTypeForBitwidth(GRLen, false);
+        if (BitWidth == 0) {
+          ZeroWidthBitFieldCount++;
+          continue;
+        }
+      }
+
+      bool Ret = detectFPCCEligibleStructHelper(
+          QTy, CurOff + getContext().toCharUnitsFromBits(FieldOffInBits),
+          Field1Ty, Field1Off, Field2Ty, Field2Off);
+      if (!Ret)
+        return false;
+
+      // As a quirk of the ABI, zero-width bitfields aren't ignored for fp+fp
+      // or int+fp structs, but are ignored for a struct with an fp field and
+      // any number of zero-width bitfields.
+      if (Field2Ty && ZeroWidthBitFieldCount > 0)
+        return false;
+    }
+    return Field1Ty != nullptr;
+  }
+
+  return false;
+}
+
+// Determine if a struct is eligible for passing according to the floating
+// point calling convention (i.e., when flattened it contains a single fp
+// value, fp+fp, or int+fp of appropriate size). If so, NeededArgFPRs and
+// NeededArgGPRs are incremented appropriately.
+bool LoongArchABIInfo::detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,
+                                            CharUnits &Field1Off,
+                                            llvm::Type *&Field2Ty,
+                                            CharUnits &Field2Off,
+                                            int &NeededArgGPRs,
+                                            int &NeededArgFPRs) const {
+  Field1Ty = nullptr;
+  Field2Ty = nullptr;
+  NeededArgGPRs = 0;
+  NeededArgFPRs = 0;
+  bool IsCandidate = detectFPCCEligibleStructHelper(
+      Ty, CharUnits::Zero(), Field1Ty, Field1Off, Field2Ty, Field2Off);
+  // Not really a candidate if we have a single int but no float.
+  if (Field1Ty && !Field2Ty && !Field1Ty->isFloatingPointTy())
+    return IsCandidate = false;
+  if (!IsCandidate)
+    return false;
+  if (Field1Ty && Field1Ty->isFloatingPointTy())
+    NeededArgFPRs++;
+  else if (Field1Ty)
+    NeededArgGPRs++;
+  if (Field2Ty && Field2Ty->isFloatingPointTy())
+    NeededArgFPRs++;
+  else if (Field2Ty)
+    NeededArgGPRs++;
+  return IsCandidate;
+}
+
+// Call getCoerceAndExpand for the two-element flattened struct described by
+// Field1Ty, Field1Off, Field2Ty, Field2Off. This method will create an
+// appropriate coerceToType and unpaddedCoerceToType.
+ABIArgInfo LoongArchABIInfo::coerceAndExpandFPCCEligibleStruct(
+    llvm::Type *Field1Ty, CharUnits Field1Off, llvm::Type *Field2Ty,
+    CharUnits Field2Off) const {
+  SmallVector<llvm::Type *, 3> CoerceElts;
+  SmallVector<llvm::Type *, 2> UnpaddedCoerceElts;
+  if (!Field1Off.isZero())
+    CoerceElts.push_back(llvm::ArrayType::get(
+        llvm::Type::getInt8Ty(getVMContext()), Field1Off.getQuantity()));
+
+  CoerceElts.push_back(Field1Ty);
+  UnpaddedCoerceElts.push_back(Field1Ty);
+
+  if (!Field2Ty) {
+    return ABIArgInfo::getCoerceAndExpand(
+        llvm::StructType::get(getVMContext(), CoerceElts, !Field1Off.isZero()),
+        UnpaddedCoerceElts[0]);
+  }
+
+  CharUnits Field2Align =
+      CharUnits::fromQuantity(getDataLayout().getABITypeAlignment(Field2Ty));
+  CharUnits Field1Size =
+      CharUnits::fromQuantity(getDataLayout().getTypeStoreSize(Field1Ty));
+  CharUnits Field2OffNoPadNoPack = Field1Size.alignTo(Field2Align);
+
+  CharUnits Padding = CharUnits::Zero();
+  if (Field2Off > Field2OffNoPadNoPack)
+    Padding = Field2Off - Field2OffNoPadNoPack;
+  else if (Field2Off != Field2Align && Field2Off > Field1Size)
+    Padding = Field2Off - Field1Size;
+
+  bool IsPacked = !Field2Off.isMultipleOf(Field2Align);
+
+  if (!Padding.isZero())
+    CoerceElts.push_back(llvm::ArrayType::get(
+        llvm::Type::getInt8Ty(getVMContext()), Padding.getQuantity()));
+
+  CoerceElts.push_back(Field2Ty);
+  UnpaddedCoerceElts.push_back(Field2Ty);
+
+  auto CoerceToType =
+      llvm::StructType::get(getVMContext(), CoerceElts, IsPacked);
+  auto UnpaddedCoerceToType =
+      llvm::StructType::get(getVMContext(), UnpaddedCoerceElts, IsPacked);
+
+  return ABIArgInfo::getCoerceAndExpand(CoerceToType, UnpaddedCoerceToType);
+}
+
+void LoongArchABIInfo::CoerceToIntArgs(
+    uint64_t TySize, SmallVectorImpl<llvm::Type *> &ArgList) const {
+  llvm::IntegerType *IntTy =
+    llvm::IntegerType::get(getVMContext(), MinABIStackAlignInBytes * 8);
+
+  // Add (TySize / MinABIStackAlignInBytes) args of IntTy.
+  for (unsigned N = TySize / (MinABIStackAlignInBytes * 8); N; --N)
+    ArgList.push_back(IntTy);
+
+  // If necessary, add one more integer type to ArgList.
+  unsigned R = TySize % (MinABIStackAlignInBytes * 8);
+
+  if (R)
+    ArgList.push_back(llvm::IntegerType::get(getVMContext(), R));
+}
+
+llvm::Type*  LoongArchABIInfo::HandleAggregates(QualType Ty, uint64_t TySize) const {
+  SmallVector<llvm::Type*, 8> ArgList, IntArgList;
+
+  if (Ty->isComplexType())
+    return CGT.ConvertType(Ty);
+
+  const RecordType *RT = Ty->getAs<RecordType>();
+
+  // Unions/vectors are passed in integer registers.
+  if (!RT || !RT->isStructureOrClassType()) {
+    CoerceToIntArgs(TySize, ArgList);
+    return llvm::StructType::get(getVMContext(), ArgList);
+  }
+
+  const RecordDecl *RD = RT->getDecl();
+  const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);
+  assert(!(TySize % 8) && "Size of structure must be multiple of 8.");
+
+  uint64_t LastOffset = 0;
+  unsigned idx = 0;
+  llvm::IntegerType *I64 = llvm::IntegerType::get(getVMContext(), 64);
+
+  // Iterate over fields in the struct/class and check if there are any aligned
+  // double fields.
+  for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();
+       i != e; ++i, ++idx) {
+    const QualType Ty = i->getType();
+    const BuiltinType *BT = Ty->getAs<BuiltinType>();
+
+    if (!BT || BT->getKind() != BuiltinType::Double)
+      continue;
+
+    uint64_t Offset = Layout.getFieldOffset(idx);
+    if (Offset % 64) // Ignore doubles that are not aligned.
+      continue;
+
+    // Add ((Offset - LastOffset) / 64) args of type i64.
+    for (unsigned j = (Offset - LastOffset) / 64; j > 0; --j)
+      ArgList.push_back(I64);
+
+    // Add double type.
+    ArgList.push_back(llvm::Type::getDoubleTy(getVMContext()));
+    LastOffset = Offset + 64;
+  }
+
+  CoerceToIntArgs(TySize - LastOffset, IntArgList);
+  ArgList.append(IntArgList.begin(), IntArgList.end());
+
+  return llvm::StructType::get(getVMContext(), ArgList);
+}
+
+llvm::Type * LoongArchABIInfo::getPaddingType(uint64_t OrigOffset,
+                                        uint64_t Offset) const {
+  if (OrigOffset + MinABIStackAlignInBytes > Offset)
+    return nullptr;
+
+  return llvm::IntegerType::get(getVMContext(), (Offset - OrigOffset) * 8);
+}
+
+ABIArgInfo LoongArchABIInfo::classifyArgumentType(QualType Ty, bool IsFixed,
+                                              int &ArgGPRsLeft,
+                                              int &ArgFPRsLeft) const {
+  assert(ArgGPRsLeft <= NumArgGPRs && "Arg GPR tracking underflow");
+  Ty = useFirstFieldIfTransparentUnion(Ty);
+
+  // Structures with either a non-trivial destructor or a non-trivial
+  // copy constructor are always passed indirectly.
+  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {
+    if (ArgGPRsLeft)
+      ArgGPRsLeft -= 1;
+    return getNaturalAlignIndirect(Ty, /*ByVal=*/RAA ==
+                                           CGCXXABI::RAA_DirectInMemory);
+  }
+
+  // Ignore empty structs/unions.
+  if (isEmptyRecord(getContext(), Ty, true))
+    return ABIArgInfo::getIgnore();
+
+  uint64_t Size = getContext().getTypeSize(Ty);
+
+  // Pass floating point values via FPRs if possible.
+  if (IsFixed && Ty->isFloatingType() && FRLen >= Size && ArgFPRsLeft) {
+    ArgFPRsLeft--;
+    return ABIArgInfo::getDirect();
+  }
+
+  // Complex types for the hard float ABI must be passed direct rather than
+  // using CoerceAndExpand.
+  if (IsFixed && Ty->isComplexType() && FRLen && ArgFPRsLeft >= 2) {
+    QualType EltTy = Ty->getAs<ComplexType>()->getElementType();
+    if (getContext().getTypeSize(EltTy) <= FRLen) {
+      ArgFPRsLeft -= 2;
+      return ABIArgInfo::getDirect();
+    }
+  }
+
+  if (IsFixed && FRLen && Ty->isStructureOrClassType()) {
+    llvm::Type *Field1Ty = nullptr;
+    llvm::Type *Field2Ty = nullptr;
+    CharUnits Field1Off = CharUnits::Zero();
+    CharUnits Field2Off = CharUnits::Zero();
+    int NeededArgGPRs;
+    int NeededArgFPRs;
+    bool IsCandidate =
+        detectFPCCEligibleStruct(Ty, Field1Ty, Field1Off, Field2Ty, Field2Off,
+                                 NeededArgGPRs, NeededArgFPRs);
+    if (IsCandidate && NeededArgGPRs <= ArgGPRsLeft &&
+        NeededArgFPRs <= ArgFPRsLeft) {
+      ArgGPRsLeft -= NeededArgGPRs;
+      ArgFPRsLeft -= NeededArgFPRs;
+      return coerceAndExpandFPCCEligibleStruct(Field1Ty, Field1Off, Field2Ty,
+                                               Field2Off);
+    }
+  } else if (Ty->isStructureOrClassType() && Size == 128 && isAggregateTypeForABI(Ty)) {
+    uint64_t Offset = 8;
+    uint64_t OrigOffset = Offset;
+    uint64_t TySize = getContext().getTypeSize(Ty);
+    uint64_t Align = getContext().getTypeAlign(Ty) / 8;
+
+    Align = std::min(std::max(Align, (uint64_t)MinABIStackAlignInBytes),
+                     (uint64_t)StackAlignInBytes);
+    unsigned CurrOffset = llvm::alignTo(Offset, Align);
+    Offset = CurrOffset + llvm::alignTo(TySize, Align * 8) / 8;
+
+    ABIArgInfo ArgInfo =
+        ABIArgInfo::getDirect(HandleAggregates(Ty, TySize), 0,
+                              getPaddingType(OrigOffset, CurrOffset));
+    ArgInfo.setInReg(true);
+    return ArgInfo;
+  }
+
+  uint64_t NeededAlign = getContext().getTypeAlign(Ty);
+  bool MustUseStack = false;
+  // Determine the number of GPRs needed to pass the current argument
+  // according to the ABI. 2*GRLen-aligned varargs are passed in "aligned"
+  // register pairs, so may consume 3 registers.
+  int NeededArgGPRs = 1;
+  if (!IsFixed && NeededAlign == 2 * GRLen)
+    NeededArgGPRs = 2 + (ArgGPRsLeft % 2);
+  else if (Size > GRLen && Size <= 2 * GRLen)
+    NeededArgGPRs = 2;
+
+  if (NeededArgGPRs > ArgGPRsLeft) {
+    MustUseStack = true;
+    NeededArgGPRs = ArgGPRsLeft;
+  }
+
+  ArgGPRsLeft -= NeededArgGPRs;
+
+  if (!isAggregateTypeForABI(Ty) && !Ty->isVectorType()) {
+    // Treat an enum type as its underlying type.
+    if (const EnumType *EnumTy = Ty->getAs<EnumType>())
+      Ty = EnumTy->getDecl()->getIntegerType();
+
+    // All integral types are promoted to GRLen width, unless passed on the
+    // stack.
+    if (Size < GRLen && Ty->isIntegralOrEnumerationType() && !MustUseStack) {
+      return extendType(Ty);
+    }
+
+    return ABIArgInfo::getDirect();
+  }
+
+  // Aggregates which are <= 2*GRLen will be passed in registers if possible,
+  // so coerce to integers.
+  if (Size <= 2 * GRLen) {
+    unsigned Alignment = getContext().getTypeAlign(Ty);
+
+    // Use a single GRLen int if possible, 2*GRLen if 2*GRLen alignment is
+    // required, and a 2-element GRLen array if only GRLen alignment is required.
+    if (Size <= GRLen) {
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), GRLen));
+    } else if (Alignment == 2 * GRLen) {
+      return ABIArgInfo::getDirect(
+          llvm::IntegerType::get(getVMContext(), 2 * GRLen));
+    } else {
+      return ABIArgInfo::getDirect(llvm::ArrayType::get(
+          llvm::IntegerType::get(getVMContext(), GRLen), 2));
+    }
+  }
+  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
+}
+
+ABIArgInfo LoongArchABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+
+  int ArgGPRsLeft = 2;
+  int ArgFPRsLeft = FRLen ? 2 : 0;
+
+  // The rules for return and argument types are the same, so defer to
+  // classifyArgumentType.
+  return classifyArgumentType(RetTy, /*IsFixed=*/true, ArgGPRsLeft,
+                              ArgFPRsLeft);
+}
+
+Address LoongArchABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                                    QualType Ty) const {
+  CharUnits SlotSize = CharUnits::fromQuantity(GRLen / 8);
+
+  // Empty records are ignored for parameter passing purposes.
+  if (isEmptyRecord(getContext(), Ty, true)) {
+    Address Addr(CGF.Builder.CreateLoad(VAListAddr), SlotSize);
+    Addr = CGF.Builder.CreateElementBitCast(Addr, CGF.ConvertTypeForMem(Ty));
+    return Addr;
+  }
+
+  std::pair<CharUnits, CharUnits> SizeAndAlign =
+      getContext().getTypeInfoInChars(Ty);
+
+  // Arguments bigger than 2*Xlen bytes are passed indirectly.
+  bool IsIndirect = SizeAndAlign.first > 2 * SlotSize;
+
+  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect, SizeAndAlign,
+                          SlotSize, /*AllowHigherAlign=*/true);
+}
+
+ABIArgInfo LoongArchABIInfo::extendType(QualType Ty) const {
+  int TySize = getContext().getTypeSize(Ty);
+  // LP64D ABI requires unsigned 32 bit integers to be sign extended.
+  if (GRLen == 64 && Ty->isUnsignedIntegerOrEnumerationType() && TySize == 32)
+    return ABIArgInfo::getSignExtend(Ty);
+  return ABIArgInfo::getExtend(Ty);
+}
+
+namespace {
+class LoongArchTargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  LoongArchTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, unsigned GRLen,
+                         unsigned FRLen)
+      : TargetCodeGenInfo(std::make_unique<LoongArchABIInfo>(
+                          CGT, GRLen, FRLen)) {}
+
+  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
+                           CodeGen::CodeGenModule &CGM) const override {
+    return;
+  }
+};
+} // namespace
+
 //===----------------------------------------------------------------------===//
 // MIPS ABI Implementation.  This works for both little-endian and
 // big-endian variants.
@@ -10905,6 +11439,9 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
   case llvm::Triple::nvptx64:
     return SetCGInfo(new NVPTXTargetCodeGenInfo(Types));
 
+  case llvm::Triple::loongarch64:
+    return SetCGInfo(new LoongArchTargetCodeGenInfo(Types, 64, 64));
+
   case llvm::Triple::msp430:
     return SetCGInfo(new MSP430TargetCodeGenInfo(Types));
 
diff --git a/clang/lib/Driver/CMakeLists.txt b/clang/lib/Driver/CMakeLists.txt
index 9463ca5c109d..e0f34be85b13 100644
--- a/clang/lib/Driver/CMakeLists.txt
+++ b/clang/lib/Driver/CMakeLists.txt
@@ -26,6 +26,7 @@ add_clang_library(clangDriver
   ToolChain.cpp
   ToolChains/Arch/AArch64.cpp
   ToolChains/Arch/ARM.cpp
+  ToolChains/Arch/LoongArch.cpp
   ToolChains/Arch/Mips.cpp
   ToolChains/Arch/PPC.cpp
   ToolChains/Arch/RISCV.cpp
diff --git a/clang/lib/Driver/Driver.cpp b/clang/lib/Driver/Driver.cpp
index ece8222dcf24..eb86256a6aa2 100644
--- a/clang/lib/Driver/Driver.cpp
+++ b/clang/lib/Driver/Driver.cpp
@@ -542,6 +542,22 @@ static llvm::Triple computeTargetTriple(const Driver &D,
     Target.setVendorName("intel");
   }
 
+  // If target is LoongArch adjust the target triple
+  // accordingly to provided ABI name.
+  A = Args.getLastArg(options::OPT_mabi_EQ);
+  if (A && Target.isLoongArch()) {
+    StringRef ABIName = A->getValue();
+    if (ABIName == "lp32") {
+      Target = Target.get32BitArchVariant();
+      if (Target.getEnvironment() == llvm::Triple::GNUABI64)
+        Target.setEnvironment(llvm::Triple::GNU);
+    } else if (ABIName == "lp64d") {
+      Target = Target.get64BitArchVariant();
+      if (Target.getEnvironment() == llvm::Triple::GNU)
+        Target.setEnvironment(llvm::Triple::GNUABI64);
+    }
+  }
+
   // If target is MIPS adjust the target triple
   // accordingly to provided ABI name.
   A = Args.getLastArg(options::OPT_mabi_EQ);
diff --git a/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp b/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
new file mode 100644
index 000000000000..8105b6fac740
--- /dev/null
+++ b/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp
@@ -0,0 +1,200 @@
+//===--- LoongArch.cpp - Tools Implementations -----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "LoongArch.h"
+#include "ToolChains/CommonArgs.h"
+#include "clang/Driver/Driver.h"
+#include "clang/Driver/DriverDiagnostic.h"
+#include "clang/Driver/Options.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/Option/ArgList.h"
+
+using namespace clang::driver;
+using namespace clang::driver::tools;
+using namespace clang;
+using namespace llvm::opt;
+
+// Get CPU and ABI names. They are not independent
+// so we have to calculate them together.
+void loongarch::getLoongArchCPUAndABI(const ArgList &Args, const llvm::Triple &Triple,
+                            StringRef &CPUName, StringRef &ABIName) {
+  const char *DefLoongArch32CPU = "loongarch32";
+  const char *DefLoongArch64CPU = "la464";
+
+  if (Arg *A = Args.getLastArg(clang::driver::options::OPT_march_EQ,
+                               options::OPT_mcpu_EQ))
+    CPUName = A->getValue();
+
+  if (Arg *A = Args.getLastArg(options::OPT_mabi_EQ)) {
+    ABIName = A->getValue();
+    // Convert a GNU style LoongArch ABI name to the name
+    // accepted by LLVM LoongArch backend.
+    ABIName = llvm::StringSwitch<llvm::StringRef>(ABIName)
+                  .Case("32", "lp32")
+                  .Case("64", "lp64d")
+                  .Default(ABIName);
+  }
+
+  // Setup default CPU and ABI names.
+  if (CPUName.empty() && ABIName.empty()) {
+    switch (Triple.getArch()) {
+    default:
+      llvm_unreachable("Unexpected triple arch name");
+    case llvm::Triple::loongarch32:
+      CPUName = DefLoongArch32CPU;
+      break;
+    case llvm::Triple::loongarch64:
+      CPUName = DefLoongArch64CPU;
+      break;
+    }
+  }
+
+  if (ABIName.empty()) {
+    ABIName = llvm::StringSwitch<const char *>(CPUName)
+                  .Case("loongarch32", "lp32")
+                  .Case("la464", "lp64d")
+                  .Default("");
+  }
+
+  if (ABIName.empty()) {
+    // Deduce ABI name from the target triple.
+    ABIName = Triple.isLoongArch32() ? "lp32" : "lp64d";
+  }
+
+  if (CPUName.empty()) {
+    // Deduce CPU name from ABI name.
+    CPUName = llvm::StringSwitch<const char *>(ABIName)
+                  .Case("lp32", DefLoongArch32CPU)
+                  .Cases("lpx32", "lp64d", DefLoongArch64CPU)
+                  .Default("");
+  }
+
+  // FIXME: Warn on inconsistent use of -march and -mabi.
+}
+
+std::string loongarch::getLoongArchABILibSuffix(const ArgList &Args,
+                                      const llvm::Triple &Triple) {
+  StringRef CPUName, ABIName;
+  tools::loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+  return llvm::StringSwitch<std::string>(ABIName)
+      .Case("lp32", "")
+      .Case("lpx32", "32")
+      .Case("lp64d", "64");
+}
+
+// Convert ABI name to the GNU tools acceptable variant.
+StringRef loongarch::getGnuCompatibleLoongArchABIName(StringRef ABI) {
+  return llvm::StringSwitch<llvm::StringRef>(ABI)
+      .Case("lp32", "32")
+      .Case("lp64d", "64")
+      .Default(ABI);
+}
+
+// Select the LoongArch float ABI as determined by -msoft-float, -mhard-float,
+// and -mfloat-abi=.
+loongarch::FloatABI loongarch::getLoongArchFloatABI(const Driver &D, const ArgList &Args) {
+  loongarch::FloatABI ABI = loongarch::FloatABI::Invalid;
+  if (Arg *A =
+          Args.getLastArg(options::OPT_msoft_float, options::OPT_mhard_float,
+                          options::OPT_mfloat_abi_EQ)) {
+    if (A->getOption().matches(options::OPT_msoft_float))
+      ABI = loongarch::FloatABI::Soft;
+    else if (A->getOption().matches(options::OPT_mhard_float))
+      ABI = loongarch::FloatABI::Hard;
+    else {
+      ABI = llvm::StringSwitch<loongarch::FloatABI>(A->getValue())
+                .Case("soft", loongarch::FloatABI::Soft)
+                .Case("hard", loongarch::FloatABI::Hard)
+                .Default(loongarch::FloatABI::Invalid);
+      if (ABI == loongarch::FloatABI::Invalid && !StringRef(A->getValue()).empty()) {
+        D.Diag(clang::diag::err_drv_invalid_mfloat_abi) << A->getAsString(Args);
+        ABI = loongarch::FloatABI::Hard;
+      }
+    }
+  }
+
+  // If unspecified, choose the default based on the platform.
+  if (ABI == loongarch::FloatABI::Invalid) {
+    // Assume "hard", because it's a default value used by gcc.
+    // When we start to recognize specific target LoongArch processors,
+    // we will be able to select the default more correctly.
+    ABI = loongarch::FloatABI::Hard;
+  }
+
+  assert(ABI != loongarch::FloatABI::Invalid && "must select an ABI");
+  return ABI;
+}
+
+void loongarch::getLoongArchTargetFeatures(const Driver &D, const llvm::Triple &Triple,
+                                 const ArgList &Args,
+                                 std::vector<StringRef> &Features) {
+  StringRef CPUName;
+  StringRef ABIName;
+  getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+  ABIName = getGnuCompatibleLoongArchABIName(ABIName);
+
+  // At final link time, LP32 and LPX32 with CPIC will have another section
+  // added to the binary which contains the stub functions to perform
+  // any fixups required for PIC code.
+
+  bool IsLP64D = ABIName == "64";
+  bool NonPIC = false;
+
+  Arg *LastPICArg = Args.getLastArg(options::OPT_fPIC, options::OPT_fno_PIC,
+                                    options::OPT_fpic, options::OPT_fno_pic,
+                                    options::OPT_fPIE, options::OPT_fno_PIE,
+                                    options::OPT_fpie, options::OPT_fno_pie);
+  if (LastPICArg) {
+    Option O = LastPICArg->getOption();
+    NonPIC =
+        (O.matches(options::OPT_fno_PIC) || O.matches(options::OPT_fno_pic) ||
+         O.matches(options::OPT_fno_PIE) || O.matches(options::OPT_fno_pie));
+  }
+
+  if (IsLP64D && NonPIC) {
+    NonPIC = false;
+  }
+
+  loongarch::FloatABI FloatABI = loongarch::getLoongArchFloatABI(D, Args);
+  if (FloatABI == loongarch::FloatABI::Soft) {
+    // FIXME: Note, this is a hack. We need to pass the selected float
+    // mode to the LoongArchTargetInfoBase to define appropriate macros there.
+    // Now it is the only method.
+    Features.push_back("+soft-float");
+  }
+
+  AddTargetFeature(Args, Features, options::OPT_msingle_float,
+                   options::OPT_mdouble_float, "single-float");
+
+  // Add the last -mfp32/-mfp64, if none are given and fp64 is default,
+  // pass fp64.
+  if (Arg *A = Args.getLastArg(options::OPT_mfp32,
+                               options::OPT_mfp64)) {
+    if (A->getOption().matches(options::OPT_mfp32))
+      Features.push_back("-fp64");
+    else
+      Features.push_back("+fp64");
+  } else if (loongarch::isFP64Default(Args)) {
+    Features.push_back("+fp64");
+  }
+
+}
+
+bool loongarch::hasLoongArchAbiArg(const ArgList &Args, const char *Value) {
+  Arg *A = Args.getLastArg(options::OPT_mabi_EQ);
+  return A && (A->getValue() == StringRef(Value));
+}
+
+bool loongarch::isUCLibc(const ArgList &Args) {
+  Arg *A = Args.getLastArg(options::OPT_m_libc_Group);
+  return A && A->getOption().matches(options::OPT_muclibc);
+}
+
+bool loongarch::isFP64Default(const ArgList &Args) {
+  return Args.getLastArg(options::OPT_msingle_float) ? false : true;
+}
diff --git a/clang/lib/Driver/ToolChains/Arch/LoongArch.h b/clang/lib/Driver/ToolChains/Arch/LoongArch.h
new file mode 100644
index 000000000000..53664346f8f8
--- /dev/null
+++ b/clang/lib/Driver/ToolChains/Arch/LoongArch.h
@@ -0,0 +1,49 @@
+//===--- LoongArch.h - LoongArch-specific Tool Helpers ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
+#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
+
+#include "clang/Driver/Driver.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Option/Option.h"
+#include <string>
+#include <vector>
+
+namespace clang {
+namespace driver {
+namespace tools {
+
+namespace loongarch {
+enum class FloatABI {
+  Invalid,
+  Soft,
+  Hard,
+};
+
+void getLoongArchCPUAndABI(const llvm::opt::ArgList &Args,
+                      const llvm::Triple &Triple, StringRef &CPUName,
+                      StringRef &ABIName);
+void getLoongArchTargetFeatures(const Driver &D, const llvm::Triple &Triple,
+                           const llvm::opt::ArgList &Args,
+                           std::vector<StringRef> &Features);
+StringRef getGnuCompatibleLoongArchABIName(StringRef ABI);
+loongarch::FloatABI getLoongArchFloatABI(const Driver &D, const llvm::opt::ArgList &Args);
+std::string getLoongArchABILibSuffix(const llvm::opt::ArgList &Args,
+                                const llvm::Triple &Triple);
+bool hasLoongArchAbiArg(const llvm::opt::ArgList &Args, const char *Value);
+bool isUCLibc(const llvm::opt::ArgList &Args);
+bool isFP64Default(const llvm::opt::ArgList &Args);
+
+} // end namespace loongarch
+} // end namespace target
+} // end namespace driver
+} // end namespace clang
+
+#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_LOONGARCH_H
diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
index af4bcf951e6c..120adfc9b744 100644
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -10,6 +10,7 @@
 #include "AMDGPU.h"
 #include "Arch/AArch64.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -330,6 +331,11 @@ static void getTargetFeatures(const Driver &D, const llvm::Triple &Triple,
     arm::getARMTargetFeatures(D, Triple, Args, CmdArgs, Features, ForAS);
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    loongarch::getLoongArchTargetFeatures(D, Triple, Args, Features);
+    break;
+
   case llvm::Triple::ppc:
   case llvm::Triple::ppc64:
   case llvm::Triple::ppc64le:
@@ -526,6 +532,8 @@ static bool useFramePointerForTargetByDefault(const ArgList &Args,
     // XCore never wants frame pointers, regardless of OS.
     // WebAssembly never wants frame pointers.
     return false;
+  case llvm::Triple::loongarch64:
+  case llvm::Triple::loongarch32:
   case llvm::Triple::ppc:
   case llvm::Triple::ppc64:
   case llvm::Triple::ppc64le:
@@ -1578,6 +1586,11 @@ void Clang::RenderTargetOptions(const llvm::Triple &EffectiveTriple,
     CmdArgs.push_back("-fallow-half-arguments-and-returns");
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    AddLoongArchTargetArgs(Args, CmdArgs);
+    break;
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -1721,6 +1734,54 @@ void Clang::AddAArch64TargetArgs(const ArgList &Args,
   }
 }
 
+void Clang::AddLoongArchTargetArgs(const ArgList &Args,
+                                   ArgStringList &CmdArgs) const {
+  const Driver &D = getToolChain().getDriver();
+  StringRef CPUName;
+  StringRef ABIName;
+  const llvm::Triple &Triple = getToolChain().getTriple();
+  loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+
+  CmdArgs.push_back("-target-abi");
+  CmdArgs.push_back(ABIName.data());
+
+  loongarch::FloatABI ABI = loongarch::getLoongArchFloatABI(D, Args);
+  if (ABI == loongarch::FloatABI::Soft) {
+    // Floating point operations and argument passing are soft.
+    CmdArgs.push_back("-msoft-float");
+    CmdArgs.push_back("-mfloat-abi");
+    CmdArgs.push_back("soft");
+  } else {
+    // Floating point operations and argument passing are hard.
+    assert(ABI == loongarch::FloatABI::Hard && "Invalid float abi!");
+    CmdArgs.push_back("-mfloat-abi");
+    CmdArgs.push_back("hard");
+  }
+
+  if (Arg *A = Args.getLastArg(options::OPT_mcheck_zero_division,
+                               options::OPT_mno_check_zero_division)) {
+    if (A->getOption().matches(options::OPT_mno_check_zero_division)) {
+      CmdArgs.push_back("-mllvm");
+      CmdArgs.push_back("-mnocheck-zero-division");
+    }
+  }
+
+  llvm::Reloc::Model RelocationModel;
+  unsigned PICLevel;
+  bool IsPIE;
+  std::tie(RelocationModel, PICLevel, IsPIE) =
+      ParsePICArgs(getToolChain(), Args);
+
+  if (Arg *A = Args.getLastArg(options::OPT_mfix_loongson3_llsc,
+                               options::OPT_mno_fix_loongson3_llsc)) {
+    CmdArgs.push_back("-mllvm");
+    if (A->getOption().matches(options::OPT_mfix_loongson3_llsc))
+      CmdArgs.push_back("-loongarch-fix-loongson3-llsc=1");
+    else
+      CmdArgs.push_back("-loongarch-fix-loongson3-llsc=0");
+  }
+}
+
 void Clang::AddMIPSTargetArgs(const ArgList &Args,
                               ArgStringList &CmdArgs) const {
   const Driver &D = getToolChain().getDriver();
@@ -6739,6 +6800,17 @@ const char *Clang::getDependencyFileName(const ArgList &Args,
 
 // Begin ClangAs
 
+void ClangAs::AddLoongArchTargetArgs(const ArgList &Args,
+                                     ArgStringList &CmdArgs) const {
+  StringRef CPUName;
+  StringRef ABIName;
+  const llvm::Triple &Triple = getToolChain().getTriple();
+  loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+
+  CmdArgs.push_back("-target-abi");
+  CmdArgs.push_back(ABIName.data());
+}
+
 void ClangAs::AddMIPSTargetArgs(const ArgList &Args,
                                 ArgStringList &CmdArgs) const {
   StringRef CPUName;
@@ -6926,6 +6998,11 @@ void ClangAs::ConstructJob(Compilation &C, const JobAction &JA,
   default:
     break;
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    AddLoongArchTargetArgs(Args, CmdArgs);
+    break;
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
diff --git a/clang/lib/Driver/ToolChains/Clang.h b/clang/lib/Driver/ToolChains/Clang.h
index a607e3c27de9..479444355540 100644
--- a/clang/lib/Driver/ToolChains/Clang.h
+++ b/clang/lib/Driver/ToolChains/Clang.h
@@ -53,6 +53,8 @@ private:
                         bool KernelOrKext) const;
   void AddARM64TargetArgs(const llvm::opt::ArgList &Args,
                           llvm::opt::ArgStringList &CmdArgs) const;
+  void AddLoongArchTargetArgs(const llvm::opt::ArgList &Args,
+                              llvm::opt::ArgStringList &CmdArgs) const;
   void AddMIPSTargetArgs(const llvm::opt::ArgList &Args,
                          llvm::opt::ArgStringList &CmdArgs) const;
   void AddPPCTargetArgs(const llvm::opt::ArgList &Args,
@@ -122,6 +124,8 @@ class LLVM_LIBRARY_VISIBILITY ClangAs : public Tool {
 public:
   ClangAs(const ToolChain &TC)
       : Tool("clang::as", "clang integrated assembler", TC) {}
+  void AddLoongArchTargetArgs(const llvm::opt::ArgList &Args,
+                              llvm::opt::ArgStringList &CmdArgs) const;
   void AddMIPSTargetArgs(const llvm::opt::ArgList &Args,
                          llvm::opt::ArgStringList &CmdArgs) const;
   void AddX86TargetArgs(const llvm::opt::ArgList &Args,
diff --git a/clang/lib/Driver/ToolChains/CommonArgs.cpp b/clang/lib/Driver/ToolChains/CommonArgs.cpp
index 6b6e276b8ce7..971036610475 100644
--- a/clang/lib/Driver/ToolChains/CommonArgs.cpp
+++ b/clang/lib/Driver/ToolChains/CommonArgs.cpp
@@ -9,6 +9,7 @@
 #include "CommonArgs.h"
 #include "Arch/AArch64.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/SystemZ.h"
@@ -296,6 +297,14 @@ std::string tools::getCPUName(const ArgList &Args, const llvm::Triple &T,
       return A->getValue();
     return "";
 
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, T, CPUName, ABIName);
+    return std::string(CPUName);
+  }
+
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -1124,6 +1133,18 @@ tools::ParsePICArgs(const ToolChain &ToolChain, const ArgList &Args) {
   if ((ROPI || RWPI) && (PIC || PIE))
     ToolChain.getDriver().Diag(diag::err_drv_ropi_rwpi_incompatible_with_pic);
 
+  if (Triple.isLoongArch()) {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, Triple, CPUName, ABIName);
+    // When targeting the LP64D ABI, PIC is the default.
+    if (ABIName == "lp64d")
+      PIC = true;
+    // Unlike other architectures, LoongArch, even with -fPIC/-mxgot/multigot,
+    // does not use PIC level 2 for historical reasons.
+    IsPICLevelTwo = false;
+  }
+
   if (Triple.isMIPS()) {
     StringRef CPUName;
     StringRef ABIName;
diff --git a/clang/lib/Driver/ToolChains/Gnu.cpp b/clang/lib/Driver/ToolChains/Gnu.cpp
index c8a7fce07ef1..aae9c93069d4 100644
--- a/clang/lib/Driver/ToolChains/Gnu.cpp
+++ b/clang/lib/Driver/ToolChains/Gnu.cpp
@@ -8,6 +8,7 @@
 
 #include "Gnu.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -269,6 +270,10 @@ static const char *getLDMOption(const llvm::Triple &T, const ArgList &Args) {
   case llvm::Triple::armeb:
   case llvm::Triple::thumbeb:
     return isArmBigEndian(T, Args) ? "armelfb_linux_eabi" : "armelf_linux_eabi";
+  case llvm::Triple::loongarch32:
+    return "elf32loongarch";
+  case llvm::Triple::loongarch64:
+    return "elf64loongarch";
   case llvm::Triple::ppc:
     return "elf32ppclinux";
   case llvm::Triple::ppc64:
@@ -823,6 +828,49 @@ void tools::gnutools::Assembler::ConstructJob(Compilation &C,
 
     break;
   }
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    StringRef CPUName;
+    StringRef ABIName;
+    loongarch::getLoongArchCPUAndABI(Args, getToolChain().getTriple(), CPUName, ABIName);
+    ABIName = loongarch::getGnuCompatibleLoongArchABIName(ABIName);
+
+    //FIXME: Currently gnu as doesn't support -march
+    //CmdArgs.push_back("-march=loongarch");
+    //CmdArgs.push_back(CPUName.data());
+
+    //FIXME: modify loongarch::getGnuCompatibleLoongArchABIName()
+    CmdArgs.push_back("-mabi=lp64d");
+    //CmdArgs.push_back(ABIName.data());
+
+    // -mno-shared should be emitted unless -fpic, -fpie, -fPIC, -fPIE,
+    // or -mshared (not implemented) is in effect.
+    if (RelocationModel == llvm::Reloc::Static)
+      CmdArgs.push_back("-mno-shared");
+
+    // LLVM doesn't support -mplt yet and acts as if it is always given.
+    // However, -mplt has no effect with the LP64D ABI.
+    if (ABIName != "64")
+      CmdArgs.push_back("-call_nonpic");
+
+    break;
+
+    // Add the last -mfp32/-mfp64.
+    if (Arg *A = Args.getLastArg(options::OPT_mfp32,
+                                 options::OPT_mfp64)) {
+      A->claim();
+      A->render(Args, CmdArgs);
+    }
+
+    Args.AddLastArg(CmdArgs, options::OPT_mhard_float,
+                    options::OPT_msoft_float);
+
+    Args.AddLastArg(CmdArgs, options::OPT_mdouble_float,
+                    options::OPT_msingle_float);
+
+    AddAssemblerKPIC(getToolChain(), Args, CmdArgs);
+    break;
+  }
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -2088,6 +2136,11 @@ void Generic_GCC::GCCInstallationDetector::AddDefaultGCCPrefixes(
       "i686-linux-android",   "i386-gnu",              "i486-gnu",
       "i586-gnu",             "i686-gnu"};
 
+  static const char *const LoongArch64LibDirs[] = {"/lib64", "/lib"};
+  static const char *const LoongArch64Triples[] = {
+      "loongarch64-linux-gnu",         "loongarch64-linux-gnuabi64",
+      "loongarch64-unknown-linux-gnu", "loongarch64-unknown-linux-gnuabi64"};
+
   static const char *const MIPSLibDirs[] = {"/lib"};
   static const char *const MIPSTriples[] = {
       "mips-linux-gnu", "mips-mti-linux", "mips-mti-linux-gnu",
@@ -2321,6 +2374,10 @@ void Generic_GCC::GCCInstallationDetector::AddDefaultGCCPrefixes(
       BiarchTripleAliases.append(begin(X86_64Triples), end(X86_64Triples));
     }
     break;
+  case llvm::Triple::loongarch64:
+    LibDirs.append(begin(LoongArch64LibDirs), end(LoongArch64LibDirs));
+    TripleAliases.append(begin(LoongArch64Triples), end(LoongArch64Triples));
+    break;
   case llvm::Triple::mips:
     LibDirs.append(begin(MIPSLibDirs), end(MIPSLibDirs));
     TripleAliases.append(begin(MIPSTriples), end(MIPSTriples));
@@ -2669,6 +2726,7 @@ bool Generic_GCC::isPICDefault() const {
   switch (getArch()) {
   case llvm::Triple::x86_64:
     return getTriple().isOSWindows();
+  case llvm::Triple::loongarch64:
   case llvm::Triple::mips64:
   case llvm::Triple::mips64el:
     return true;
@@ -2707,6 +2765,8 @@ bool Generic_GCC::IsIntegratedAssemblerDefault() const {
   case llvm::Triple::mips64:
   case llvm::Triple::mips64el:
   case llvm::Triple::msp430:
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
     return true;
   case llvm::Triple::sparc:
   case llvm::Triple::sparcel:
diff --git a/clang/lib/Driver/ToolChains/Linux.cpp b/clang/lib/Driver/ToolChains/Linux.cpp
index 180350476c38..fec429b7a519 100644
--- a/clang/lib/Driver/ToolChains/Linux.cpp
+++ b/clang/lib/Driver/ToolChains/Linux.cpp
@@ -8,6 +8,7 @@
 
 #include "Linux.h"
 #include "Arch/ARM.h"
+#include "Arch/LoongArch.h"
 #include "Arch/Mips.h"
 #include "Arch/PPC.h"
 #include "Arch/RISCV.h"
@@ -102,6 +103,18 @@ std::string Linux::getMultiarchTriple(const Driver &D,
     if (D.getVFS().exists(SysRoot + "/lib/aarch64_be-linux-gnu"))
       return "aarch64_be-linux-gnu";
     break;
+  case llvm::Triple::loongarch32: {
+    std::string MT = "loongarch32-linux-gnu";
+    if (D.getVFS().exists(SysRoot + "/lib/" + MT))
+      return MT;
+    break;
+  }
+  case llvm::Triple::loongarch64: {
+    std::string MT = "loongarch64-linux-gnu";
+    if (D.getVFS().exists(SysRoot + "/lib/" + MT))
+      return MT;
+    break;
+  }
   case llvm::Triple::mips: {
     std::string MT = IsMipsR6 ? "mipsisa32r6-linux-gnu" : "mips-linux-gnu";
     if (D.getVFS().exists(SysRoot + "/lib/" + MT))
@@ -472,6 +485,13 @@ std::string Linux::getDynamicLinker(const ArgList &Args) const {
     Loader = HF ? "ld-linux-armhf.so.3" : "ld-linux.so.3";
     break;
   }
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64: {
+    LibDir = "lib" + tools::loongarch::getLoongArchABILibSuffix(Args, Triple);
+    //TODO: support other ABIs
+    Loader = "ld-linux-loongarch-lp64d.so.1";
+    break;
+  }
   case llvm::Triple::mips:
   case llvm::Triple::mipsel:
   case llvm::Triple::mips64:
@@ -652,6 +672,10 @@ void Linux::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
       "/usr/include/sparc64-linux-gnu"};
   const StringRef SYSTEMZMultiarchIncludeDirs[] = {
       "/usr/include/s390x-linux-gnu"};
+  const StringRef LoongArch32MultiarchIncludeDirs[] = {
+      "/usr/include/loongarch32-linux-gnu"};
+  const StringRef LoongArch64MultiarchIncludeDirs[] = {
+      "/usr/include/loongarch64-linux-gnu"};
   ArrayRef<StringRef> MultiarchIncludeDirs;
   switch (getTriple().getArch()) {
   case llvm::Triple::x86_64:
@@ -730,6 +754,12 @@ void Linux::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
   case llvm::Triple::systemz:
     MultiarchIncludeDirs = SYSTEMZMultiarchIncludeDirs;
     break;
+  case llvm::Triple::loongarch64:
+    MultiarchIncludeDirs = LoongArch64MultiarchIncludeDirs;
+    break;
+  case llvm::Triple::loongarch32:
+    MultiarchIncludeDirs = LoongArch32MultiarchIncludeDirs;
+    break;
   default:
     break;
   }
diff --git a/clang/lib/Driver/XRayArgs.cpp b/clang/lib/Driver/XRayArgs.cpp
index f00c3906df97..730ae52ba62e 100644
--- a/clang/lib/Driver/XRayArgs.cpp
+++ b/clang/lib/Driver/XRayArgs.cpp
@@ -41,6 +41,8 @@ XRayArgs::XRayArgs(const ToolChain &TC, const ArgList &Args) {
     case llvm::Triple::arm:
     case llvm::Triple::aarch64:
     case llvm::Triple::ppc64le:
+    case llvm::Triple::loongarch32:
+    case llvm::Triple::loongarch64:
     case llvm::Triple::mips:
     case llvm::Triple::mipsel:
     case llvm::Triple::mips64:
diff --git a/clang/lib/Headers/CMakeLists.txt b/clang/lib/Headers/CMakeLists.txt
index 0692fe75a441..19a8e0ccddcd 100644
--- a/clang/lib/Headers/CMakeLists.txt
+++ b/clang/lib/Headers/CMakeLists.txt
@@ -72,6 +72,7 @@ set(files
   inttypes.h
   invpcidintrin.h
   iso646.h
+  larchintrin.h
   limits.h
   lwpintrin.h
   lzcntintrin.h
diff --git a/clang/lib/Headers/larchintrin.h b/clang/lib/Headers/larchintrin.h
new file mode 100644
index 000000000000..7e99f19a3828
--- /dev/null
+++ b/clang/lib/Headers/larchintrin.h
@@ -0,0 +1,319 @@
+//===----------- larchintrin.h - LoongArch BASE intrinsics ------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the LoongArch Base intrinsics
+//
+//===----------------------------------------------------------------------===//
+#ifndef __LOONGARCH_BASE_H
+#define __LOONGARCH_BASE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drdtime{
+	unsigned long dvalue;
+	unsigned long dtimeid;
+} __drdtime_t;
+
+typedef struct rdtime{
+	unsigned int value;
+	unsigned int timeid;
+} __rdtime_t;
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned int, uimm14_32 */
+#define __csrrd(/*uimm14_32*/ _1)	((unsigned int)__builtin_loongarch_csrrd(_1))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned int, uimm14_32 */
+#define __csrwr(/*unsigned int*/ _1, /*uimm14_32*/ _2)	((unsigned int)__builtin_loongarch_csrwr((unsigned int)(_1), (_2)))
+
+/* Assembly instruction format:          rd, rj, csr_num */
+/* Data types in instruction templates:  unsigned int, unsigned int, uimm14_32 */
+#define __csrxchg(/*unsigned int*/ _1, /*unsigned int*/ _2, /*uimm14_32*/ _3) ((unsigned int)__builtin_loongarch_csrxchg((unsigned int)(_1), (unsigned int)(_2), (_3)))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned long int, uimm14 */
+#define __dcsrrd(/*uimm14*/ _1)	((unsigned long int)__builtin_loongarch_dcsrrd(_1))
+
+/* Assembly instruction format:          rd, csr_num */
+/* Data types in instruction templates:  unsigned long int, uimm14 */
+#define __dcsrwr(/*unsigned long int*/ _1, /*uimm14*/ _2)	((unsigned long int)__builtin_loongarch_dcsrwr((unsigned long int)(_1), (_2)))
+
+/* Assembly instruction format:          rd, rj, csr_num */
+/* Data types in instruction templates:  unsigned long int, unsigned long int, uimm14 */
+#define __dcsrxchg(/*unsigned long int*/ _1, /*unsigned long int*/ _2, /*uimm14*/ _3) ((unsigned long int)__builtin_loongarch_dcsrxchg((unsigned long int)(_1), (unsigned long int)(_2), (_3)))
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned char, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned char __iocsrrd_b(unsigned int _1)
+{
+	return (unsigned char)__builtin_loongarch_iocsrrd_b((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned short, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned short __iocsrrd_h(unsigned int _1)
+{
+	return (unsigned short)__builtin_loongarch_iocsrrd_h((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned int __iocsrrd_w(unsigned int _1)
+{
+	return (unsigned int)__builtin_loongarch_iocsrrd_w((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates: unsigned long int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+unsigned long int __iocsrrd_d(unsigned int _1)
+{
+	return (unsigned long int)__builtin_loongarch_iocsrrd_d((unsigned int)_1);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned char, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_b(unsigned char _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_b((unsigned char)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned short, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_h(unsigned short _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_h((unsigned short)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates:  unsigned int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_w(unsigned int _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_w((unsigned int)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          rd, rj */
+/* Data types in instruction templates: unsigned long int, unsigned int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __iocsrwr_d(unsigned long int _1, unsigned int _2)
+{
+	return (void)__builtin_loongarch_iocsrwr_d((unsigned long int)_1, (unsigned int)_2);
+}
+
+/* Assembly instruction format:          op, rj, si12 */
+/* Data types in instruction templates: uimm5, unsigned int, simm12 */
+#define __cacop(/*uimm5*/ _1, /*unsigned int*/ _2, /*simm12*/ _3) ((void)__builtin_loongarch_cacop((_1), (unsigned int)(_2), (_3)))
+
+/* Assembly instruction format:          op, rj, si12 */
+/* Data types in instruction templates: uimm5, unsigned long int, simm12 */
+#define __dcacop(/*uimm5*/ _1, /*unsigned long int*/ _2, /*simm12*/ _3)	((void)__builtin_loongarch_dcacop((_1), (unsigned long int)(_2), (_3)))
+
+#define __rdtime_d	__builtin_loongarch_rdtime_d
+#define __rdtimel_w	__builtin_loongarch_rdtimel_w
+#define __rdtimeh_w	__builtin_loongarch_rdtimeh_w
+
+extern __inline __drdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtime_d (void)
+{
+  __drdtime_t drdtime;
+  __asm__ volatile (
+    "rdtime.d\t%[val],%[tid]\n\t"
+    : [val]"=&r"(drdtime.dvalue),[tid]"=&r"(drdtime.dtimeid)
+    :
+  );
+  return drdtime;
+}
+
+extern __inline __rdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtimeh_w (void)
+{
+  __rdtime_t rdtime;
+  __asm__ volatile (
+    "rdtimeh.w\t%[val],%[tid]\n\t"
+    : [val]"=&r"(rdtime.value),[tid]"=&r"(rdtime.timeid)
+    :
+  );
+  return rdtime;
+}
+
+extern __inline __rdtime_t __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+__builtin_loongarch_rdtimel_w (void)
+{
+  __rdtime_t rdtime;
+  __asm__ volatile (
+    "rdtimel.w\t%[val],%[tid]\n\t"
+    : [val]"=&r"(rdtime.value),[tid]"=&r"(rdtime.timeid)
+    :
+  );
+  return rdtime;
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, char, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_b_w(char _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_b_w((char)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, short, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_h_w(short _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_h_w((short)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_w_w(int _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_w_w((int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates: int, long int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crc_w_d_w(long int _1, int _2)
+{
+	return (int)__builtin_loongarch_crc_w_d_w((long int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, char, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_b_w(char _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_b_w((char)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, short, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_h_w(short _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_h_w((short)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates:  int, int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_w_w(int _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_w_w((int)_1, (int)_2);
+}
+
+/* Assembly instruction format:          rd, rj, rk */
+/* Data types in instruction templates: int, long int, int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+int __crcc_w_d_w(long int _1, int _2)
+{
+	return (int)__builtin_loongarch_crcc_w_d_w((long int)_1, (int)_2);
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbclr()
+{
+	return (void)__builtin_loongarch_tlbclr();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbflush()
+{
+	return (void)__builtin_loongarch_tlbflush();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbfill()
+{
+	return (void)__builtin_loongarch_tlbfill();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbrd()
+{
+	return (void)__builtin_loongarch_tlbrd();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbwr()
+{
+	return (void)__builtin_loongarch_tlbwr();
+}
+
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __tlbsrch()
+{
+	return (void)__builtin_loongarch_tlbsrch();
+}
+
+/* Assembly instruction format:          code */
+/* Data types in instruction templates:  uimm15 */
+#define __syscall(/*uimm15*/ _1)	((void)__builtin_loongarch_syscall(_1))
+
+/* Assembly instruction format:          code */
+/* Data types in instruction templates:  uimm15 */
+#define __break(/*uimm15*/ _1)	((void)__builtin_loongarch_break(_1))
+
+/* Assembly instruction format:          hint */
+/* Data types in instruction templates:  uimm15 */
+#define __dbar(/*uimm15*/ _1)	((void)__builtin_loongarch_dbar(_1))
+
+/* Assembly instruction format:          hint */
+/* Data types in instruction templates:  uimm15 */
+#define __ibar(/*uimm15*/ _1)	((void)__builtin_loongarch_ibar(_1))
+
+/* Assembly instruction format:          rj, rk */
+/* Data types in instruction templates:  long int, long int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __asrtle_d(long int _1, long int _2)
+{
+	return (void)__builtin_loongarch_asrtle_d((long int)_1, (long int)_2);
+}
+
+/* Assembly instruction format:          rj, rk */
+/* Data types in instruction templates:  long int, long int */
+extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
+void __asrtgt_d(long int _1, long int _2)
+{
+	return (void)__builtin_loongarch_asrtgt_d((long int)_1, (long int)_2);
+}
+
+#define __movfcsr2gr(uimm5) \
+({ \
+  unsigned int rd; \
+  __asm__ volatile ( \
+    "movfcsr2gr %0, $fcsr" #uimm5 \
+    : "=&r"(rd) \
+    : \
+  ); rd; \
+})
+
+#define __movgr2fcsr(uimm5, rj) \
+{ \
+  __asm__ volatile ( \
+    "movgr2fcsr $fcsr" #uimm5 ", %0" \
+    : \
+    : "r" (rj) \
+  ); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __LOONGARCH_BASE_H */
diff --git a/clang/lib/Sema/SemaChecking.cpp b/clang/lib/Sema/SemaChecking.cpp
index b00d2ff5f1d5..df077f31a0c3 100644
--- a/clang/lib/Sema/SemaChecking.cpp
+++ b/clang/lib/Sema/SemaChecking.cpp
@@ -1430,6 +1430,9 @@ bool Sema::CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,
     return CheckPPCBuiltinFunctionCall(TI, BuiltinID, TheCall);
   case llvm::Triple::amdgcn:
     return CheckAMDGCNBuiltinFunctionCall(BuiltinID, TheCall);
+  case llvm::Triple::loongarch32:
+  case llvm::Triple::loongarch64:
+    return CheckLoongArchBuiltinFunctionCall(TI, BuiltinID, TheCall);
   }
 }
 
@@ -3194,6 +3197,45 @@ bool Sema::CheckAMDGCNBuiltinFunctionCall(unsigned BuiltinID,
   return false;
 }
 
+// CheckLoongArchBuiltinFunctionCall - Checks the constant value passed to the
+// intrinsic is correct.
+//
+// FIXME: The size tests here should instead be tablegen'd along with the
+//        definitions from include/clang/Basic/BuiltinsLoongArch.def.
+// FIXME: GCC is strict on signedness for some of these intrinsics, we should
+//        be too.
+bool Sema::CheckLoongArchBuiltinFunctionCall(const TargetInfo &TI,
+                                             unsigned BuiltinID,
+                                             CallExpr *TheCall) {
+  unsigned i = 0, l = 0, u = 0, m = 0;
+  switch (BuiltinID) {
+  default: return false;
+  // These intrinsics take an unsigned 5 bit immediate and a signed 12 bit immediate.
+  case LoongArch::BI__builtin_loongarch_cacop:
+  case LoongArch::BI__builtin_loongarch_dcacop:
+    return SemaBuiltinConstantArgRange(TheCall, 0, 0, 31) ||
+           SemaBuiltinConstantArgRange(TheCall, 2, -2048, 2047);
+  // These intrinsics take an unsigned 14 bit immediate.
+  case LoongArch::BI__builtin_loongarch_csrrd:
+  case LoongArch::BI__builtin_loongarch_dcsrrd: i = 0; l = 0; u = 16383; break;
+  case LoongArch::BI__builtin_loongarch_csrwr:
+  case LoongArch::BI__builtin_loongarch_dcsrwr: i = 1; l = 0; u = 16383; break;
+  case LoongArch::BI__builtin_loongarch_csrxchg:
+  case LoongArch::BI__builtin_loongarch_dcsrxchg: i = 2; l = 0; u = 16383; break;
+  // These intrinsics take an unsigned 15 bit immediate.
+  case LoongArch::BI__builtin_loongarch_dbar:
+  case LoongArch::BI__builtin_loongarch_ibar:
+  case LoongArch::BI__builtin_loongarch_syscall:
+  case LoongArch::BI__builtin_loongarch_break: i = 0; l = 0; u = 32767; break;
+  }
+
+  if (!m)
+    return SemaBuiltinConstantArgRange(TheCall, i, l, u);
+
+  return SemaBuiltinConstantArgRange(TheCall, i, l, u) ||
+         SemaBuiltinConstantArgMultiple(TheCall, i, m);
+}
+
 bool Sema::CheckSystemZBuiltinFunctionCall(unsigned BuiltinID,
                                            CallExpr *TheCall) {
   if (BuiltinID == SystemZ::BI__builtin_tabort) {
diff --git a/clang/test/CodeGen/builtins-loongarch-base.c b/clang/test/CodeGen/builtins-loongarch-base.c
new file mode 100644
index 000000000000..d72213590a50
--- /dev/null
+++ b/clang/test/CodeGen/builtins-loongarch-base.c
@@ -0,0 +1,417 @@
+// REQUIRES: loongarch-registered-target
+// RUN: %clang_cc1 -triple loongarch64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+
+#include <larchintrin.h>
+
+typedef char i8;
+typedef unsigned char u8;
+typedef short i16;
+typedef unsigned short u16;
+typedef int i32;
+typedef unsigned int u32;
+
+#if __LONG_MAX__ == __LONG_LONG_MAX__
+typedef long int i64;
+typedef unsigned long int u64;
+#else
+typedef long long i64;
+typedef unsigned long long u64;
+#endif
+
+__drdtime_t drdtime;
+__rdtime_t rdtime;
+
+void cpucfg(){
+
+  u32 u32_r, u32_a;
+  // __cpucfg
+  // rd, rj
+  // unsigned int, unsigned int
+  u32_r= __builtin_loongarch_cpucfg(u32_a); // CHECK: call i32 @llvm.loongarch.cpucfg
+
+}
+
+void csrrd(){
+
+  u32 u32_r;
+  // __csrrd
+  // rd, csr_num
+  // unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrrd(1); // CHECK: call i32 @llvm.loongarch.csrrd
+
+}
+
+void dcsrrd(){
+
+  u64 u64_r;
+  // __dcsrrd
+  // rd, csr_num
+  // unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrrd(1); // CHECK: call i64 @llvm.loongarch.dcsrrd
+
+}
+
+void csrwr(){
+
+  u32 u32_r, u32_a;
+  // __csrwr
+  // rd, csr_num
+  // unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrwr(u32_a, 1); // CHECK: call i32 @llvm.loongarch.csrwr
+
+}
+
+void dcsrwr(){
+
+  u64 u64_r, u64_a;
+  // __dcsrwr
+  // rd, csr_num
+  // unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrwr(u64_a, 1); // CHECK: call i64 @llvm.loongarch.dcsrwr
+
+}
+
+void csrxchg(){
+
+  u32 u32_r, u32_a, u32_b;
+  // __csrxchg
+  // rd, rj, csr_num
+  // unsigned int, unsigned int, uimm14_32
+  u32_r=__builtin_loongarch_csrxchg(u32_a, u32_b, 1); // CHECK: call i32 @llvm.loongarch.csrxchg
+
+}
+
+void dcsrxchg(){
+
+  u64 u64_r, u64_a, u64_b;
+  // __dcsrxchg
+  // rd, rj, csr_num
+  // unsigned long int, unsigned long int, uimm14
+  u64_r=__builtin_loongarch_dcsrxchg(u64_a, u64_b, 1); // CHECK: call i64 @llvm.loongarch.dcsrxchg
+
+}
+
+void iocsrrd_b(){
+
+  u32 u32_a;
+  u8 u8_r;
+  // __iocsrrd_b
+  // rd, rj
+  // unsigned char, unsigned int
+  u8_r=__builtin_loongarch_iocsrrd_b(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.b
+
+}
+
+void iocsrrd_h(){
+
+  u32 u32_a;
+  u16 u16_r;
+  // __iocsrrd_h
+  // rd, rj
+  // unsigned short, unsigned int
+  u16_r=__builtin_loongarch_iocsrrd_h(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.h
+
+}
+
+void iocsrrd_w(){
+
+  u32 u32_r, u32_a;
+  // __iocsrrd_w
+  // rd, rj
+  // unsigned int, unsigned int
+  u32_r=__builtin_loongarch_iocsrrd_w(u32_a); // CHECK: call i32 @llvm.loongarch.iocsrrd.w
+
+}
+
+void iocsrrd_d(){
+
+  u32 u32_a;
+  u64 u64_r;
+  // __iocsrrd_d
+  // rd, rj
+  // unsigned long int, unsigned int
+  u64_r=__builtin_loongarch_iocsrrd_d(u32_a); // CHECK: call i64 @llvm.loongarch.iocsrrd.d
+
+}
+
+void iocsrwr_b(){
+
+  u32 u32_a;
+  u8 u8_a;
+  // __iocsrwr_b
+  // rd, rj
+  // unsigned char, unsigned int
+  __builtin_loongarch_iocsrwr_b(u8_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.b
+
+}
+
+void iocsrwr_h(){
+
+  u32 u32_a;
+  u16 u16_a;
+  // __iocsrwr_h
+  // rd, rj
+  // unsigned short, unsigned int
+  __builtin_loongarch_iocsrwr_h(u16_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.h
+
+}
+
+void iocsrwr_w(){
+
+  u32 u32_a, u32_b;
+  // __iocsrwr_w
+  // rd, rj
+  // unsigned int, unsigned int
+  __builtin_loongarch_iocsrwr_w(u32_a, u32_b); // CHECK: void @llvm.loongarch.iocsrwr.w
+
+}
+
+void iocsrwr_d(){
+
+  u32 u32_a;
+  u64 u64_a;
+  // __iocsrwr_d
+  // rd, rj
+  // unsigned long int, unsigned int
+  __builtin_loongarch_iocsrwr_d(u64_a, u32_a); // CHECK: void @llvm.loongarch.iocsrwr.d
+
+}
+
+void cacop(){
+
+  i32 i32_a;
+  // __cacop
+  // op, rj, si12
+  // uimm5, unsigned int, simm12
+  __builtin_loongarch_cacop(1, i32_a, 2); // CHECK: void @llvm.loongarch.cacop
+
+}
+
+void dcacop(){
+
+  i64 i64_a;
+  // __dcacop
+  // op, rj, si12
+  // uimm5, unsigned long int, simm12
+  __builtin_loongarch_dcacop(1, i64_a, 2); // CHECK: void @llvm.loongarch.dcacop
+
+}
+
+void rdtime_d(){
+
+  drdtime= __builtin_loongarch_rdtime_d(); // CHECK: call { i64, i64 } asm sideeffect "rdtime.d\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void rdtimeh_w(){
+
+  rdtime= __builtin_loongarch_rdtimeh_w(); // CHECK: call { i32, i32 } asm sideeffect "rdtimeh.w\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void rdtimel_w(){
+
+  rdtime= __builtin_loongarch_rdtimel_w(); // CHECK: call { i32, i32 } asm sideeffect "rdtimel.w\09$0,$1\0A\09", "=&r,=&r"()
+
+}
+
+void crc_w_b_w(){
+
+  i32 i32_r, i32_a;
+  i8 i8_a;
+  // __crc_w_b_w
+  // rd, rj, rk
+  // int, char, int
+  i32_r=__builtin_loongarch_crc_w_b_w(i8_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.b.w
+
+}
+
+void crc_w_h_w(){
+
+  i32 i32_r, i32_a;
+  i16 i16_a;
+  // __crc_w_h_w
+  // rd, rj, rk
+  // int, short, int
+  i32_r=__builtin_loongarch_crc_w_h_w(i16_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.h.w
+
+}
+
+void crc_w_w_w(){
+
+  i32 i32_r, i32_a, i32_b;
+  // __crc_w_w_w
+  // rd, rj, rk
+  // int, int, int
+  i32_r=__builtin_loongarch_crc_w_w_w(i32_a, i32_b); // CHECK: call i32 @llvm.loongarch.crc.w.w.w
+
+}
+
+void crc_w_d_w(){
+
+  i32 i32_r, i32_a;
+  i64 i64_a;
+  // __crc_w_d_w
+  // rd, rj, rk
+  // int, long int, int
+  i32_r=__builtin_loongarch_crc_w_d_w(i64_a, i32_a); // CHECK: call i32 @llvm.loongarch.crc.w.d.w
+
+}
+
+void crcc_w_b_w(){
+
+  i32 i32_r, i32_a;
+  i8 i8_a;
+  // __crcc_w_b_w
+  // rd, rj, rk
+  // int, char, int
+  i32_r=__builtin_loongarch_crcc_w_b_w(i8_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.b.w
+
+}
+
+void crcc_w_h_w(){
+
+  i32 i32_r, i32_a;
+  i16 i16_a;
+  // __crcc_w_h_w
+  // rd, rj, rk
+  // int, short, int
+  i32_r=__builtin_loongarch_crcc_w_h_w(i16_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.h.w
+
+}
+
+void crcc_w_w_w(){
+
+  i32 i32_r, i32_a, i32_b;
+  // __crcc_w_w_w
+  // rd, rj, rk
+  // int, int, int
+  i32_r=__builtin_loongarch_crcc_w_w_w(i32_a, i32_b); // CHECK: call i32 @llvm.loongarch.crcc.w.w.w
+
+}
+
+void crcc_w_d_w(){
+
+  i32 i32_r, i32_a;
+  i64 i64_a;
+  // __crcc_w_d_w
+  // rd, rj, rk
+  // int, long int, int
+  i32_r=__builtin_loongarch_crcc_w_d_w(i64_a, i32_a); // CHECK: call i32 @llvm.loongarch.crcc.w.d.w
+
+}
+
+void tlbclr(){
+
+  // __tlbclr
+  __builtin_loongarch_tlbclr(); // CHECK: call void @llvm.loongarch.tlbclr
+
+}
+
+void tlbflush(){
+
+  // __tlbflush
+  __builtin_loongarch_tlbflush(); // CHECK: call void @llvm.loongarch.tlbflush
+
+}
+
+void tlbfill(){
+
+  // __tlbfill
+  __builtin_loongarch_tlbfill(); // CHECK: call void @llvm.loongarch.tlbfill 
+
+}
+
+void tlbrd(){
+
+  // __tlbrd
+  __builtin_loongarch_tlbrd(); // CHECK: call void @llvm.loongarch.tlbrd
+
+}
+
+void tlbwr(){
+
+  // __tlbwr
+  __builtin_loongarch_tlbwr(); // CHECK: call void @llvm.loongarch.tlbwr
+
+}
+
+void tlbsrch(){
+
+  // __tlbsrch
+  __builtin_loongarch_tlbsrch(); // CHECK: call void @llvm.loongarch.tlbsrch
+
+}
+
+void syscall(){
+
+  // __syscall
+  // Code
+  // uimm15
+  __builtin_loongarch_syscall(1); // CHECK: call void @llvm.loongarch.syscall
+
+}
+
+void break_builtin(){
+
+  // __break
+  // Code
+  // uimm15
+  __builtin_loongarch_break(1); // CHECK: call void @llvm.loongarch.break
+
+}
+
+void asrtle_d(){
+
+  i64 i64_a, i64_b;
+  // __asrtle_d
+  // rj, rk
+  // long int, long int
+  __builtin_loongarch_asrtle_d(i64_a, i64_b); // CHECK: call void @llvm.loongarch.asrtle.d
+
+}
+
+void asrtgt_d(){
+
+  i64 i64_a, i64_b;
+  // __asrtgt_d
+  // rj, rk
+  // long int, long int
+  __builtin_loongarch_asrtgt_d(i64_a, i64_b); // CHECK: call void @llvm.loongarch.asrtgt.d
+
+}
+
+void dbar(){
+
+  // __dbar
+  // hint
+  // uimm15
+  __builtin_loongarch_dbar(0); // CHECK: call void @llvm.loongarch.dbar
+
+}
+
+void ibar(){
+
+  // __ibar
+  // hint
+  // uimm15
+  __builtin_loongarch_ibar(0); // CHECK: call void @llvm.loongarch.ibar
+
+}
+
+void movfcsr2gr(){
+
+  u32 u32_r;
+  // __movfcsr2gr
+  u32_r=__movfcsr2gr(0); // CHECK: call i32 asm sideeffect "movfcsr2gr $0, $$fcsr0", "=&r"()
+
+}
+
+
+void movgr2fcsr() {
+
+  u32 u32_a;
+  // __movgr2fcsr
+  __movgr2fcsr(0, u32_a); // CHECK: call void asm sideeffect "movgr2fcsr $$fcsr0, $0", "r"(i32 %0)
+
+}
diff --git a/clang/test/CodeGen/loongarch-inline-asm-modifiers.c b/clang/test/CodeGen/loongarch-inline-asm-modifiers.c
new file mode 100644
index 000000000000..7f3beb9c4f68
--- /dev/null
+++ b/clang/test/CodeGen/loongarch-inline-asm-modifiers.c
@@ -0,0 +1,40 @@
+// RUN: %clang -target loongarch64-unknown-linux-gnu -S -o - -emit-llvm %s \
+// RUN: | FileCheck %s
+
+// This checks that the frontend will accept inline asm operand modifiers
+
+int printf(const char*, ...);
+
+typedef long long v2i64 __attribute__ ((vector_size(16), aligned(16)));
+typedef long long v4i64 __attribute__ ((vector_size(32), aligned(32)));
+
+  // CHECK: %{{[0-9]+}} = call i32 asm ".set noreorder;\0Ald.w    $0,$1;\0A.set reorder;\0A", "=r,*m"(i32* getelementptr inbounds ([8 x i32], [8 x i32]* @b, i32 {{[0-9]+}}, i64 {{[0-9]+}})) #2,
+  // CHECK: %{{[0-9]+}} = call i32 asm "ld.w    $0,${1:D};\0A", "=r,*m"(i32* getelementptr inbounds ([8 x i32], [8 x i32]* @b, i32 {{[0-9]+}}, i64 {{[0-9]+}})) #2,
+int b[8] = {0,1,2,3,4,5,6,7};
+int  main()
+{
+  int i;
+  v2i64 v2i64_r;
+  v4i64 v4i64_r;
+
+  // The first word. Notice, no 'D'
+  {asm (
+  ".set noreorder;\n"
+  "ld.w    %0,%1;\n"
+  ".set reorder;\n"
+  : "=r" (i)
+  : "m" (*(b+4)));}
+
+  printf("%d\n",i);
+
+  // The second word
+  {asm (
+  "ld.w    %0,%D1;\n"
+  : "=r" (i)
+  : "m" (*(b+4))
+  );}
+
+  printf("%d\n",i);
+
+  return 1;
+}
diff --git a/clang/test/CodeGen/loongarch-inline-asm.c b/clang/test/CodeGen/loongarch-inline-asm.c
new file mode 100644
index 000000000000..a75f00d20ef3
--- /dev/null
+++ b/clang/test/CodeGen/loongarch-inline-asm.c
@@ -0,0 +1,31 @@
+// REQUIRES: loongarch-registered-target
+// RUN: %clang_cc1 -triple loongarch64-linux-gnu -emit-llvm -o - %s | FileCheck %s
+
+int data;
+
+void m () {
+  asm("ld.w $r1, %0" :: "m"(data));
+  // CHECK: call void asm sideeffect "ld.w $$r1, $0", "*m"(i32* @data)
+}
+
+void ZC () {
+  asm("ll.w $r1, %0" :: "ZC"(data));
+  // CHECK: call void asm sideeffect "ll.w $$r1, $0", "*^ZC"(i32* @data)
+}
+
+void ZB () {
+  asm("amadd_db.w $zero, $r1, %0" :: "ZB"(data));
+  // CHECK: call void asm sideeffect "amadd_db.w $$zero, $$r1, $0", "*^ZB"(i32* @data)
+}
+
+void R () {
+  asm("ld.w $r1, %0" :: "R"(data));
+  // CHECK: call void asm sideeffect "ld.w $$r1, $0", "*R"(i32* @data)
+}
+
+int *p;
+void preld () {
+  asm("preld 0, %0, 2" :: "r"(p));
+  // CHECK: %0 = load i32*, i32** @p, align 8
+  // CHECK: call void asm sideeffect "preld 0, $0, 2", "r"(i32* %0)
+}

